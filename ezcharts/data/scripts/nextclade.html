<script type="module">
const NAMESPACE = 'nextclade';

let scopeId;
let hostTagName;
let isSvgMode = false;
let queuePending = false;
const win = typeof window !== 'undefined' ? window : {};
const doc = win.document || { head: {} };
const H = (win.HTMLElement || class {
});
const plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (h) => h(),
    raf: (h) => requestAnimationFrame(h),
    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts) => new CustomEvent(eventName, opts),
};
const promiseResolve = (v) => Promise.resolve(v);
const supportsConstructibleStylesheets = /*@__PURE__*/ (() => {
        try {
            new CSSStyleSheet();
            return typeof new CSSStyleSheet().replace === 'function';
        }
        catch (e) { }
        return false;
    })()
    ;
const XLINK_NS = 'http://www.w3.org/1999/xlink';
const createTime = (fnName, tagName = '') => {
    {
        return () => {
            return;
        };
    }
};
const rootAppliedStyles = new WeakMap();
const registerStyle = (scopeId, cssText, allowCS) => {
    let style = styles.get(scopeId);
    if (supportsConstructibleStylesheets && allowCS) {
        style = (style || new CSSStyleSheet());
        style.replace(cssText);
    }
    else {
        style = cssText;
    }
    styles.set(scopeId, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
    let scopeId = getScopeId(cmpMeta);
    let style = styles.get(scopeId);
    // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases
    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;
    if (style) {
        if (typeof style === 'string') {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));
            }
            if (!appliedStyles.has(scopeId)) {
                {
                    {
                        styleElm = doc.createElement('style');
                        styleElm.innerHTML = style;
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId);
                }
            }
        }
        else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
    }
    return scopeId;
};
const attachStyles = (hostRef) => {
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    const scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
    if (flags & 10 /* needsScopedEncapsulation */) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
        if (flags & 2 /* scopedCssEncapsulation */) {
            elm.classList.add(scopeId + '-s');
        }
    }
    endAttachStyles();
};
const getScopeId = (cmp, mode) => 'sc-' + (cmp.$tagName$);
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
/**
 * Namespaces
 */
const SVG_NS = 'http://www.w3.org/2000/svg';
const HTML_NS = 'http://www.w3.org/1999/xhtml';
const isDef = (v) => v != null;
const isComplexType$1 = (o) => {
    // https://jsperf.com/typeof-fn-object/5
    o = typeof o;
    return o === 'object' || o === 'function';
};
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// const stack: any[] = [];
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h$1 = (nodeName, vnodeData, ...children) => {
    let child = null;
    let key = null;
    let simple = false;
    let lastSimple = false;
    let vNodeChildren = [];
    const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
            child = c[i];
            if (Array.isArray(child)) {
                walk(child);
            }
            else if (child != null && typeof child !== 'boolean') {
                if ((simple = typeof nodeName !== 'function' && !isComplexType$1(child))) {
                    child = String(child);
                }
                if (simple && lastSimple) {
                    // If the previous child was simple (string), we merge both
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                }
                else {
                    // Append a new vNode, if it's text, we create a text vNode
                    vNodeChildren.push(simple ? newVNode$1(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        // normalize class / classname attributes
        if (vnodeData.key) {
            key = vnodeData.key;
        }
        {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class =
                    typeof classData !== 'object'
                        ? classData
                        : Object.keys(classData)
                            .filter((k) => classData[k])
                            .join(' ');
            }
        }
    }
    if (typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils$1);
    }
    const vnode = newVNode$1(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    {
        vnode.$key$ = key;
    }
    return vnode;
};
const newVNode$1 = (tag, text) => {
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null,
    };
    {
        vnode.$attrs$ = null;
    }
    {
        vnode.$key$ = null;
    }
    return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
const vdomFnUtils$1 = {
    forEach: (children, cb) => children.map(convertToPublic$1).forEach(cb),
    map: (children, cb) => children.map(convertToPublic$1).map(cb).map(convertToPrivate$1),
};
const convertToPublic$1 = (node) => ({
    vattrs: node.$attrs$,
    vchildren: node.$children$,
    vkey: node.$key$,
    vname: node.$name$,
    vtag: node.$tag$,
    vtext: node.$text$,
});
const convertToPrivate$1 = (node) => {
    if (typeof node.vtag === 'function') {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h$1(node.vtag, vnodeData, ...(node.vchildren || []));
    }
    const vnode = newVNode$1(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (memberName === 'class') {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
        }
        else if (memberName === 'style') {
            // update style attribute, css properties and values
            {
                for (const prop in oldValue) {
                    if (!newValue || newValue[prop] == null) {
                        if (prop.includes('-')) {
                            elm.style.removeProperty(prop);
                        }
                        else {
                            elm.style[prop] = '';
                        }
                    }
                }
            }
            for (const prop in newValue) {
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (prop.includes('-')) {
                        elm.style.setProperty(prop, newValue[prop]);
                    }
                    else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        }
        else if (memberName === 'key')
            ;
        else if (memberName === 'ref') {
            // minifier will clean this up
            if (newValue) {
                newValue(elm);
            }
        }
        else if ((!elm.__lookupSetter__(memberName)) &&
            memberName[0] === 'o' &&
            memberName[1] === 'n') {
            // Event Handlers
            // so if the member name starts with "on" and the 3rd characters is
            // a capital letter, and it's not already a member on the element,
            // then we're assuming it's an event listener
            if (memberName[2] === '-') {
                // on- prefixed events
                // allows to be explicit about the dom event to listen without any magic
                // under the hood:
                // <my-cmp on-click> // listens for "click"
                // <my-cmp on-Click> // listens for "Click"
                // <my-cmp on-ionChange> // listens for "ionChange"
                // <my-cmp on-EVENTS> // listens for "EVENTS"
                memberName = memberName.slice(3);
            }
            else if (isMemberInElement(win, ln)) {
                // standard event
                // the JSX attribute could have been "onMouseOver" and the
                // member name "onmouseover" is on the window's prototype
                // so let's add the listener "mouseover", which is all lowercased
                memberName = ln.slice(2);
            }
            else {
                // custom event
                // the JSX attribute could have been "onMyCustomEvent"
                // so let's trim off the "on" prefix and lowercase the first character
                // and add the listener "myCustomEvent"
                // except for the first character, we keep the event name case
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        }
        else {
            // Set property if it exists and it's not a SVG
            const isComplex = isComplexType$1(newValue);
            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
                try {
                    if (!elm.tagName.includes('-')) {
                        let n = newValue == null ? '' : newValue;
                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                        if (memberName === 'list') {
                            isProp = false;
                        }
                        else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    }
                    else {
                        elm[memberName] = newValue;
                    }
                }
                catch (e) { }
            }
            /**
             * Need to manually update attribute if:
             * - memberName is not an attribute
             * - if we are rendering the host element in order to reflect attribute
             * - if it's a SVG, since properties might not work in <svg>
             * - if the newValue is null/undefined or 'false'.
             */
            let xlink = false;
            {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === '') {
                    if (xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    }
                    else {
                        elm.removeAttribute(memberName);
                    }
                }
            }
            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {
                newValue = newValue === true ? '' : newValue;
                if (xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                }
                else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host
        ? newVnode.$elm$.host
        : newVnode.$elm$;
    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    {
        // remove attributes no longer present on the vnode by setting them to undefined
        for (memberName in oldVnodeAttrs) {
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
            }
        }
    }
    // add new & update changed attributes
    for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
};
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
    // tslint:disable-next-line: prefer-const
    let newVNode = newParentVNode.$children$[childIndex];
    let i = 0;
    let elm;
    let childNode;
    if (newVNode.$text$ !== null) {
        // create text node
        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    }
    else {
        if (!isSvgMode) {
            isSvgMode = newVNode.$tag$ === 'svg';
        }
        // create element
        elm = newVNode.$elm$ = (doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$tag$)
            );
        if (isSvgMode && newVNode.$tag$ === 'foreignObject') {
            isSvgMode = false;
        }
        // add css classes, attrs, props, listeners, etc.
        {
            updateElement(null, newVNode, isSvgMode);
        }
        if (isDef(scopeId) && elm['s-si'] !== scopeId) {
            // if there is a scopeId and this is the initial render
            // then let's add the scopeId as a css class
            elm.classList.add((elm['s-si'] = scopeId));
        }
        if (newVNode.$children$) {
            for (i = 0; i < newVNode.$children$.length; ++i) {
                // create the node
                childNode = createElm(oldParentVNode, newVNode, i);
                // return node could have been null
                if (childNode) {
                    // append our new node
                    elm.appendChild(childNode);
                }
            }
        }
        {
            if (newVNode.$tag$ === 'svg') {
                // Only reset the SVG context when we're exiting <svg> element
                isSvgMode = false;
            }
            else if (elm.tagName === 'foreignObject') {
                // Reenter SVG context when we're exiting <foreignObject> element
                isSvgMode = true;
            }
        }
    }
    return elm;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
    let containerElm = (parentElm);
    let childNode;
    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, before);
            }
        }
    }
};
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
    for (; startIdx <= endIdx; ++startIdx) {
        if ((vnode = vnodes[startIdx])) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            // remove the vnode's element from the dom
            elm.remove();
        }
    }
};
const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
            // Vnode might have been moved left
            oldStartVnode = oldCh[++oldStartIdx];
        }
        else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        }
        else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        }
        else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newStartVnode)) {
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else if (isSameVnode(oldEndVnode, newEndVnode)) {
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newEndVnode)) {
            patch(oldStartVnode, newEndVnode);
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldEndVnode, newStartVnode)) {
            patch(oldEndVnode, newStartVnode);
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else {
            // createKeyToOldIdx
            idxInOld = -1;
            {
                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                        idxInOld = i;
                        break;
                    }
                }
            }
            if (idxInOld >= 0) {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld);
                }
                else {
                    patch(elmToMove, newStartVnode);
                    oldCh[idxInOld] = undefined;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                // new element
                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    }
    else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
const isSameVnode = (vnode1, vnode2) => {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (vnode1.$tag$ === vnode2.$tag$) {
        {
            return vnode1.$key$ === vnode2.$key$;
        }
    }
    return false;
};
const patch = (oldVNode, newVNode) => {
    const elm = (newVNode.$elm$ = oldVNode.$elm$);
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode.$children$;
    const tag = newVNode.$tag$;
    const text = newVNode.$text$;
    if (text === null) {
        {
            // test if we're rendering an svg element, or still rendering nodes inside of one
            // only add this to the when the compiler sees we're using an svg somewhere
            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
        }
        // element node
        {
            if (tag === 'slot')
                ;
            else {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(oldVNode, newVNode, isSvgMode);
            }
        }
        if (oldChildren !== null && newChildren !== null) {
            // looks like there's child vnodes for both the old and new vnodes
            updateChildren(elm, oldChildren, newVNode, newChildren);
        }
        else if (newChildren !== null) {
            // no old child vnodes, but there are new child vnodes to add
            if (oldVNode.$text$ !== null) {
                // the old vnode was text, so be sure to clear it out
                elm.textContent = '';
            }
            // add the new vnode children
            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
        }
        else if (oldChildren !== null) {
            // no new child vnodes, but there are old child vnodes to remove
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (isSvgMode && tag === 'svg') {
            isSvgMode = false;
        }
    }
    else if (oldVNode.$text$ !== text) {
        // update the text content for the text only vnode
        // and also only if the text is different than before
        elm.data = text;
    }
};
const callNodeRefs = (vNode) => {
    {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
const renderVdom = (hostRef, renderFnResults) => {
    const hostElm = hostRef.$hostElement$;
    const oldVNode = hostRef.$vnode$ || newVNode$1(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h$1(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4 /* isHost */;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm.shadowRoot || hostElm );
    {
        scopeId = hostElm['s-sc'];
    }
    // synchronous patch
    patch(oldVNode, rootVnode);
};
/**
 * Helper function to create & dispatch a custom Event on a provided target
 * @param elm the target of the Event
 * @param name the name to give the custom Event
 * @param opts options for configuring a custom Event
 * @returns the custom Event
 */
const emitEvent = (elm, name, opts) => {
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
const attachToAncestor = (hostRef, ancestorComponent) => {
    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
    }
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
    {
        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;
    }
    if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {
        hostRef.$flags$ |= 512 /* needsRerender */;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    // there is no ancestor component or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update
    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
    return writeTask(dispatch) ;
};
const dispatchHooks = (hostRef, isInitialLoad) => {
    const elm = hostRef.$hostElement$;
    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    const instance = elm;
    let promise;
    if (isInitialLoad) {
        {
            promise = safeCall(instance, 'componentWillLoad');
        }
    }
    endSchedule();
    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
    // updateComponent
    const elm = hostRef.$hostElement$;
    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    const rc = elm['s-rc'];
    if (isInitialLoad) {
        // DOM WRITE!
        attachStyles(hostRef);
    }
    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    {
        callRender(hostRef, instance);
    }
    if (rc) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        rc.map((cb) => cb());
        elm['s-rc'] = undefined;
    }
    endRender();
    endUpdate();
    {
        const childrenPromises = elm['s-p'];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
            postUpdate();
        }
        else {
            Promise.all(childrenPromises).then(postUpdate);
            hostRef.$flags$ |= 4 /* isWaitingForChildren */;
            childrenPromises.length = 0;
        }
    }
};
const callRender = (hostRef, instance, elm) => {
    try {
        instance = instance.render() ;
        {
            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;
        }
        {
            hostRef.$flags$ |= 2 /* hasRendered */;
        }
        {
            {
                // looks like we've got child nodes to render into this host element
                // or we need to update the css class/attrs on the host element
                // DOM WRITE!
                {
                    renderVdom(hostRef, instance);
                }
            }
        }
    }
    catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    return null;
};
const postUpdateComponent = (hostRef) => {
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime('postUpdate', tagName);
    const instance = elm;
    const ancestorComponent = hostRef.$ancestorComponent$;
    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {
        hostRef.$flags$ |= 64 /* hasLoadedComponent */;
        {
            // DOM WRITE!
            addHydratedFlag(elm);
        }
        {
            safeCall(instance, 'componentDidLoad');
        }
        endPostUpdate();
        {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad();
            }
        }
    }
    else {
        endPostUpdate();
    }
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = undefined;
        }
        if (hostRef.$flags$ & 512 /* needsRerender */) {
            nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);
    }
    // ( •_•)
    // ( •_•)>⌐■-■
    // (⌐■_■)
};
const appDidLoad = (who) => {
    // on appload
    // we have finish the first big initial render
    {
        addHydratedFlag(doc.documentElement);
    }
    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));
};
const safeCall = (instance, method, arg) => {
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        }
        catch (e) {
            consoleError(e);
        }
    }
    return undefined;
};
const then = (promise, thenFn) => {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
const addHydratedFlag = (elm) => elm.classList.add('hydrated')
    ;
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */
const parsePropertyValue = (propValue, propType) => {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType$1(propValue)) {
        if (propType & 4 /* Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return propValue === 'false' ? false : propValue === '' || !!propValue;
        }
        if (propType & 2 /* Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
        if (propType & 1 /* String */) {
            // could have been passed as a number or boolean
            // but we still want it as a string
            return String(propValue);
        }
        // redundant return here for better minification
        return propValue;
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
};
const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
    // check our new property value against our internal value
    const hostRef = getHostRef(ref);
    const elm = ref;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = elm;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    if (newVal !== oldVal) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        hostRef.$instanceValues$.set(propName, newVal);
        {
            // get an array of method names of watch functions to call
            if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    // this instance is watching for when this property changed
                    watchMethods.map((watchMethodName) => {
                        try {
                            // fire off each of the watch methods that are watching this property
                            instance[watchMethodName](newVal, oldVal, propName);
                        }
                        catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
                // looks like this value actually changed, so we've got work to do!
                // but only if we've already rendered, otherwise just chill out
                // queue that we need to do an update, but don't worry about queuing
                // up millions cuz this function ensures it only runs once
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
const proxyComponent = (Cstr, cmpMeta, flags) => {
    if (cmpMeta.$members$) {
        if (Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        // It's better to have a const than two Object.entries()
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
            if ((memberFlags & 31 /* Prop */ ||
                    (memberFlags & 32 /* State */))) {
                // proxyComponent - prop
                Object.defineProperty(prototype, memberName, {
                    get() {
                        // proxyComponent, get value
                        return getValue(this, memberName);
                    },
                    set(newValue) {
                        // proxyComponent, set value
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true,
                });
            }
        });
        {
            const attrNameToPropName = new Map();
            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
                plt.jmp(() => {
                    const propName = attrNameToPropName.get(attrName);
                    if (this.hasOwnProperty(propName)) {
                        newValue = this[propName];
                        delete this[propName];
                    }
                    else if (prototype.hasOwnProperty(propName) &&
                        typeof this[propName] === 'number' &&
                        this[propName] == newValue) {
                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
                        return;
                    }
                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
                });
            };
            // create an array of attributes to observe
            // and also create a map of html attribute name to js property name
            Cstr.observedAttributes = members
                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes
                .map(([propName, m]) => {
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                return attrName;
            });
        }
    }
    return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
    // initializeComponent
    if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {
        {
            // sync constructor component
            Cstr = elm.constructor;
            hostRef.$flags$ |= 32 /* hasInitializedComponent */;
            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,
            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_
            // Stencil has completed instantiating the component.
            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));
        }
        if (Cstr.style) {
            // this component has styles but we haven't registered them yet
            let style = Cstr.style;
            const scopeId = getScopeId(cmpMeta);
            if (!styles.has(scopeId)) {
                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));
                endRegisterStyles();
            }
        }
    }
    // we've successfully created a lazy instance
    const ancestorComponent = hostRef.$ancestorComponent$;
    const schedule = () => scheduleUpdate(hostRef, true);
    if (ancestorComponent && ancestorComponent['s-rc']) {
        // this is the initial load and this component it has an ancestor component
        // but the ancestor component has NOT fired its will update lifecycle yet
        // so let's just cool our jets and wait for the ancestor to continue first
        // this will get fired off when the ancestor component
        // finally gets around to rendering its lazy self
        // fire off the initial update
        ancestorComponent['s-rc'].push(schedule);
    }
    else {
        schedule();
    }
};
const connectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {
            // first time this component has connected
            hostRef.$flags$ |= 1 /* hasConnected */;
            {
                // find the first ancestor component (if there is one) and register
                // this component as one of the actively loading child components for its ancestor
                let ancestorComponent = elm;
                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
                    // climb up the ancestors looking for the first
                    // component that hasn't finished its lifecycle update yet
                    if (ancestorComponent['s-p']) {
                        // we found this components first ancestor component
                        // keep a reference to this component's ancestor component
                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
                        break;
                    }
                }
            }
            // Lazy properties
            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
            if (cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        }
        endConnected();
    }
};
const disconnectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
        getHostRef(elm);
    }
};
const proxyCustomElement = (Cstr, compactMeta) => {
    const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1],
    };
    {
        cmpMeta.$members$ = compactMeta[2];
    }
    {
        cmpMeta.$watchers$ = Cstr.$watchers$;
    }
    const originalConnectedCallback = Cstr.prototype.connectedCallback;
    Object.assign(Cstr.prototype, {
        __registerHost() {
            registerHost(this, cmpMeta);
        },
        connectedCallback() {
            connectedCallback(this);
            if (originalConnectedCallback) {
                originalConnectedCallback.call(this);
            }
        },
        disconnectedCallback() {
            disconnectedCallback(this);
        },
        __attachShadow() {
            {
                {
                    this.attachShadow({ mode: 'open' });
                }
            }
        },
    });
    Cstr.is = cmpMeta.$tagName$;
    return proxyComponent(Cstr, cmpMeta);
};
const setAssetPath = (path) => (plt.$resourcesUrl$ = path);
const setPlatformOptions = (opts) => Object.assign(plt, opts);
const hostRefs = new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerHost = (elm, cmpMeta) => {
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: new Map(),
    };
    {
        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
        elm['s-p'] = [];
        elm['s-rc'] = [];
    }
    return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e, el) => (0, console.error)(e, el);
const styles = new Map();
const queueDomReads = [];
const queueDomWrites = [];
const queueTask = (queue, write) => (cb) => {
    queue.push(cb);
    if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4 /* queueSync */) {
            nextTick(flush);
        }
        else {
            plt.raf(flush);
        }
    }
};
const consume = (queue) => {
    for (let i = 0; i < queue.length; i++) {
        try {
            queue[i](performance.now());
        }
        catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
const flush = () => {
    // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!
    consume(queueDomReads);
    // DOM WRITES!!!
    {
        consume(queueDomWrites);
        if ((queuePending = queueDomReads.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
    }
};
const nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);
const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);

const nxtButtonCss = ":host{--color-green-dark:#00857c;--color-off-white:#f8f7f2;--ion-color-secondary:var(--color-green-dark);--ion-color-secondary-contrast:var(--color-off-white);--padding-start:calc(10/16 * 1rem);--padding-end:calc(10/16 * 1rem);padding-top:0.375rem;padding-bottom:0.375rem;height:1.8125rem;--border-width:calc(2/16 * 1rem)}:host>button{align-items:flex-start;padding-left:unset;padding-right:unset;padding-inline-start:var(--padding-start);padding-inline-end:var(--padding-end);border:0.125rem solid var(--color-green-dark)}:host .button-inner{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}";

let NxtButton$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return (h$1(Host, null, h$1("button", { type: "button", class: "button-native", part: "native" }, h$1("span", { class: "button-inner" }, h$1("slot", { name: "start" }), h$1("slot", null))), h$1("div", { role: "img", "aria-label": "filter outline" }, h$1("div", { class: "icon-inner" }, h$1("svg", { xmlns: "http://www.w3.org/2000/svg", class: "ionicon s-ion-icon", viewBox: "0 0 512 512" }, h$1("title", null, "Filter"), h$1("path", { "stroke-linecap": "round", "stroke-linejoin": "round", d: "M32 144h448M112 256h288M208 368h96", class: "ionicon-fill-none ionicon-stroke-width" }))))));
  }
  static get style() { return nxtButtonCss; }
};

const nxtCircleCss = ":host{border-radius:50%;display:inline-flex;margin:0.1rem;color:#fff;font-weight:500;width:1.5rem;height:1.5rem;justify-content:center;align-items:center;cursor:default}:host([status=good]){background-color:#68b844}:host([status=bad]){background-color:#da4e3c}:host([status=mediocre]){background-color:#e4902f}";

let NxtCircle$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return (h$1(Host, Object.assign({}, { status: this.status }), h$1("slot", null)));
  }
  static get style() { return nxtCircleCss; }
};

const debounce$2 = (func, wait, immediate) => {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = null;
      if (!immediate)
        func.apply(context, args);
    }, wait);
    if (immediate && !timeout)
      func.apply(context, args);
  };
};
function getPath(o, path) {
  return path.split('.').reduce((p, c) => (c in (p || {}) ? p[c] : undefined), o);
}
function isNullish(obj) {
  return obj === null || typeof obj === 'undefined';
}

const nxtFilterCss = ".sc-nxt-filter-h{transition:all 0.3s ease;visibility:hidden;overflow-y:hidden;opacity:0;height:0;padding:0 0.5rem;width:100%;display:flex;justify-content:space-between;flex-direction:column}[open].sc-nxt-filter-h{visibility:visible;opacity:1;display:flex;height:revert;justify-content:stretch;padding:1rem 0.5rem}[open].sc-nxt-filter-h>h4.sc-nxt-filter{margin:-0.5rem 0 1rem;font-weight:300}[open].sc-nxt-filter-h>div.sc-nxt-filter{display:flex;height:revert;justify-content:space-between}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter{display:inline-block;background-color:rgba(255, 255, 255, 0.9);border-radius:3px;margin:0;color:#333;width:auto;flex:1;margin:0.2rem;font-size:0.75rem}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter{display:flex;flex-direction:column;margin:0.5rem}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter{display:flex;flex-direction:column;padding-top:0.3rem}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .container.sc-nxt-filter{display:flex;align-items:center;position:relative;padding-left:2rem;line-height:2;margin-bottom:0.2rem;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .container.sc-nxt-filter:hover input.sc-nxt-filter~.checkmark.sc-nxt-filter{background-color:#fff}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .container.sc-nxt-filter input.sc-nxt-filter{position:absolute;opacity:0;cursor:pointer;height:0;width:0}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .container.sc-nxt-filter input.sc-nxt-filter:checked~.checkmark.sc-nxt-filter{background-color:#4377cd}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .container.sc-nxt-filter .checkmark.sc-nxt-filter{position:absolute;top:0;left:0;height:1.3rem;width:1.3rem;background-color:#ccc}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .container.sc-nxt-filter .checkmark.sc-nxt-filter:after{left:0.375rem;top:0.125rem;width:0.3125rem;height:0.625rem;border:solid white;border-width:0 0.1875rem 0.1875rem 0;-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .checkmark.sc-nxt-filter:after{content:\"\";position:absolute;display:none}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>#checkboxes.sc-nxt-filter .container.sc-nxt-filter input.sc-nxt-filter:checked~.checkmark.sc-nxt-filter:after{display:block}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>input.sc-nxt-filter{margin-top:0.5rem;display:block;padding:0.5rem;border:1px solid #777;border-radius:3px;font-size:inherit;color:#555}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>input.sc-nxt-filter:focus{outline:none}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>input.sc-nxt-filter::-webkit-input-placeholder{color:#ccc}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>input.sc-nxt-filter::-moz-placeholder{color:#ccc}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>input.sc-nxt-filter:-ms-input-placeholder{color:#ccc}[open].sc-nxt-filter-h>div.sc-nxt-filter>p.sc-nxt-filter>label.sc-nxt-filter>input.sc-nxt-filter:-moz-placeholder{color:#ccc}";

let NxtFilter$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.open = false;
    this.status = {
      good: true,
      mediocre: true,
      bad: true,
      errors: true,
    };
    this.debounceTextInput = (field) => {
      const input = this.hostEl.querySelector(`input[name=${field}]`);
      return debounce$2(() => {
        this.handlers[field](input.value);
      }, 500);
    };
    this.debounceCheckboxInput = (field) => {
      const input = this.hostEl.querySelectorAll(`input[name=${field}]`);
      return debounce$2(() => {
        const values = Array.from(input).map(i => i.checked && i.id);
        this.handlers[field](values);
      }, 300);
    };
  }
  render() {
    return (h$1(Host, { open: this.open }, h$1("h4", null, "Results filter"), h$1("div", null, h$1("p", null, h$1("label", { htmlFor: "seqName" }, "By sequence name", h$1("input", { name: "seqName", type: "text", placeholder: "Eg.: Wuhan, WH", onInput: this.debounceTextInput('seqName') }))), h$1("p", null, h$1("label", { htmlFor: "nucChanges" }, "By nucleotide mutations", h$1("input", { name: "nucChanges", type: "text", placeholder: "Eg.: C3037T, A", onInput: this.debounceTextInput('nucChanges') }))), h$1("p", null, h$1("label", { htmlFor: "aaChanges" }, "By aminoacid changes", h$1("input", { name: "aaChanges", type: "text", placeholder: "Eg.: ORF1b:P314L, S:, :84, ORF1b:P314-", onInput: this.debounceTextInput('aaChanges') }))), h$1("p", null, h$1("label", { htmlFor: "cladeChanges" }, "By clades", h$1("input", { name: "cladeChanges", type: "text", placeholder: "Ex.: 19B, 20", onInput: this.debounceTextInput('cladeChanges') }))), h$1("p", null, h$1("label", { htmlFor: "statusChanges" }, "By quality", h$1("div", { id: "checkboxes", onChange: this.debounceCheckboxInput('statusChanges') }, h$1("label", { class: "container", htmlFor: "good" }, h$1("input", { type: "checkbox", name: "statusChanges", id: "good", checked: this.status.good }), h$1("span", { class: "checkmark" }), "Good quality"), h$1("label", { class: "container", htmlFor: "mediocre" }, h$1("input", { type: "checkbox", name: "statusChanges", id: "mediocre", checked: this.status.mediocre }), h$1("span", { class: "checkmark" }), "Mediocre quality"), h$1("label", { class: "container", htmlFor: "bad" }, h$1("input", { type: "checkbox", name: "statusChanges", id: "bad", checked: this.status.bad }), h$1("span", { class: "checkmark" }), "Bad quality"), h$1("label", { class: "container", htmlFor: "errors" }, h$1("input", { type: "checkbox", name: "statusChanges", id: "errors", checked: this.status.errors }), h$1("span", { class: "checkmark" }), "Has errors")))))));
  }
  get hostEl() { return this; }
  static get style() { return nxtFilterCss; }
};

const nxtLogoCss = ":host{display:flex;align-items:center;width:8.5rem}:host>svg{margin-right:0.5rem;width:var(--icon-width);height:var(--icon-width)}:host>div>span{font-size:1.2rem}";

let NxtLogo$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return (h$1(Host, null, h$1("svg", { viewBox: "0 0 76.68 76.955", part: "logo-image" }, h$1("path", { d: "M37.045 76.918l-.64-.031-.947-.414c-.52-.227-.965-.429-.988-.448-.023-.019.785-.718 1.796-1.552l1.837-1.519 1.808 1.215c.995.668 1.803 1.231 1.796 1.253-.007.02-.438.358-.959.75l-.946.712-.39.04c-.434.044-1.394.042-2.367-.006z", fill: "#a6be55" }), h$1("path", { d: "M41.836 76.766c.001-.025.226-.212.5-.413l.498-.368.614.141c.337.078.614.155.614.172 0 .018-.132.099-.293.18-.224.115-.435.164-.905.212-.337.034-.706.076-.821.092-.115.017-.208.01-.207-.016z", fill: "#b9bc4a" }), h$1("path", { d: "M29.249 75.713a24.78 24.78 0 01-1.309-.227c-.543-.124-2.703-.84-2.808-.931a4.358 4.358 0 00-.495-.287c-.324-.168-.392-.224-.334-.277.15-.136 7.092-4.003 7.173-3.996.098.01 5.41 2.34 5.473 2.403.024.023-.815.754-1.865 1.624l-1.91 1.582-.918.095c-1.62.166-1.985.168-3.007.014z", fill: "#92bc63" }), h$1("path", { d: "M46.647 75.63c-.59-.067-1.377-.214-2.311-.431l-1.417-.33-2.31-1.556-2.311-1.556-3.09-1.355c-1.7-.746-3.177-1.396-3.282-1.445-.13-.06-1.217-1.24-3.375-3.663l-3.183-3.574.064-.464c.034-.254.538-3.848 1.118-7.984l1.055-7.522 5.39-3.306c4.708-2.889 5.47-3.337 6.015-3.547.343-.132.657-.24.697-.24.04 0 2.384 1.17 5.21 2.598l5.136 2.598 4.639 10.289 4.639 10.289-1.765 3.555L55.8 71.54l-1.444 1.163c-1.428 1.151-1.453 1.168-2.32 1.578-.481.228-.913.448-.959.489-.087.077-1.64.578-2.569.83-.614.165-.655.166-1.862.029z", fill: "#80b974" }), h$1("path", { d: "M22.149 73.152c-.46-.163-.877-.298-.928-.3-.111-.003-1.197-.576-2.196-1.158l-.73-.425-.823-1.33-.824-1.328-1.046-3.018-1.045-3.018.622-.034c.342-.019 2.59-.044 4.998-.056l4.376-.021 2.993 3.36c1.646 1.847 2.985 3.367 2.974 3.378-.013.013-6.904 3.897-7.508 4.231-.015.009-.404-.118-.863-.28zM57.374 70.859c.002-.023.684-1.395 1.517-3.05l1.515-3.006 2.673-1.655 2.673-1.654.015.178c.01.099-.046 1.017-.123 2.04l-.14 1.861-.67.678c-.368.373-.67.704-.67.737 0 .062-.99.925-1.852 1.613-.332.266-.86.593-1.555.966-.9.482-1.22.62-2.204.948-1.281.429-1.183.4-1.18.344z", fill: "#6eb389" }), h$1("path", { d: "M15.578 69.416c-.33-.252-.304-.29.095-.136.123.048.375.397.284.394-.025-.001-.195-.117-.38-.258z", fill: "#80b974" }), h$1("path", { d: "M14.297 67.653c-.784-.272-.884-.324-1.636-.846a13.79 13.79 0 01-1.302-1.03c-.576-.543-1.879-1.944-1.879-2.019 0-.027-.242-.418-.537-.867-.455-.69-1.279-2.222-1.225-2.275.014-.015 5.548 1.764 5.596 1.799.028.02 1.902 5.425 1.902 5.485 0 .07-.002.07-.92-.247z", fill: "#549db2" }), h$1("path", { d: "M66.743 63.898c.019-.207.077-1.007.13-1.778l.096-1.402 1.247-.9c.686-.495 1.263-.885 1.282-.866.019.019-.017.57-.08 1.225l-.113 1.19-.49.632c-1.021 1.315-1.893 2.275-2.065 2.275-.022 0-.025-.17-.006-.376z", fill: "#b9bc4a" }), h$1("path", { d: "M55.702 53.694c-2.46-5.455-4.462-9.925-4.45-9.936.062-.053 20.944-7.611 20.99-7.596.028.01.8 1.25 1.712 2.755l1.66 2.737.213 1.87.215 1.868-.147.91c-.081.5-.147.997-.147 1.104 0 .196-.306 1.385-.62 2.409-.1.326-.395 1.012-.698 1.623l-.526 1.058-1.022 1.17a142.39 142.39 0 00-2.043 2.404l-1.022 1.236-1.845 1.33c-1.47 1.06-2.432 1.693-4.735 3.118-1.589.984-2.929 1.805-2.977 1.823-.07.027-.958-1.898-4.558-9.883z", fill: "#a6be55" }), h$1("path", { d: "M10.382 60.297l-3.47-1.131-1.115-1.106-1.114-1.106-.692-1.394c-.38-.767-.692-1.458-.692-1.537 0-.078-.139-1.162-.308-2.409l-.308-2.267 2.376-3.02c1.307-1.66 2.43-3.074 2.494-3.14l.117-.12 9.37 1.405c5.152.773 9.38 1.417 9.394 1.431.03.03-2.113 15.354-2.153 15.394-.026.026-1.877.052-7.7.106l-2.73.025z", fill: "#60aa9e" }), h$1("path", { d: "M70.626 59.326c0-.041.027-.379.063-.751l.064-.677.393-.466c.216-.257.4-.445.409-.418.009.026-.017.299-.057.605-.069.526-.09.585-.386 1.058-.385.616-.484.748-.486.65z", fill: "#cbb742" }), h$1("path", { d: "M1.444 47.259l-.658-.973-.135-.69c-.303-1.554-.39-2.381-.36-3.467l.028-1.012 2.06-1.703c1.133-.937 2.084-1.696 2.113-1.686.029.01.55 1.064 1.158 2.343l1.106 2.326-.489.622c-2.542 3.232-4.096 5.19-4.127 5.2-.021.007-.334-.425-.696-.96z", fill: "#549db2" }), h$1("path", { d: "M17.304 43.397l-9.522-1.432-.16-.331c-.09-.182-.663-1.384-1.275-2.67l-1.115-2.339-.634-2.164-.635-2.164-.167-1.706a40.223 40.223 0 00-.441-3.251c-.217-1.22-.289-1.777-.34-2.646l-.064-1.1.361-.807c.199-.444.5-1.085.67-1.424.295-.587.345-.65 1.08-1.374.687-.676.943-.878 2.36-1.862l1.59-1.104 5.76-.575c10.351-1.033 14.833-1.448 14.901-1.38.034.034 2.141 3.257 4.682 7.162l4.62 7.1.1 4.14c.055 2.317.078 4.158.05 4.182-.026.023-.318.146-.65.273-.518.198-1.352.69-6.047 3.572-2.995 1.838-5.48 3.34-5.523 3.337-.043-.003-4.364-.65-9.601-1.437z", fill: "#e56a2f" }), h$1("path", { d: "M45.398 40.268a4334.205 4334.205 0 00-5.075-2.57c-.02-.008-.08-1.89-.136-4.18l-.101-4.166 6.304-6.304 6.303-6.303 4.803-.852c2.642-.469 4.853-.85 4.915-.85.06.002 1.346.33 2.856.73l2.744.727 1.46.712 1.46.712.453.775c.25.426.598 1.035.773 1.354l.32.58.598 2.539c.375 1.592.697 3.122.864 4.104l.266 1.566-1.073 3.086-1.073 3.086-10.72 3.896c-5.896 2.143-10.76 3.9-10.81 3.904-.05.005-2.36-1.14-5.13-2.546z", fill: "#cbb742" }), h$1("path", { d: "M75.606 39.51c-1.518-2.49-2.476-4.098-2.475-4.154.002-.132 1.764-5.13 1.814-5.145.028-.008.351.44.719.994l.668 1.01.12.84c.067.463.151 1.18.188 1.593.064.715.06.802-.081 1.782-.132.913-.615 3.442-.668 3.495-.01.01-.14-.176-.285-.415z", fill: "#b9bc4a" }), h$1("path", { d: "M.162 39.677a4.86 4.86 0 01-.067-.49c-.02-.215-.056-.428-.08-.474-.05-.103.036-3.06.095-3.218.036-.097 2.741-2.088 2.94-2.164.04-.016.092.07.13.214.034.132.247.871.473 1.643l.411 1.403-1.872 1.544c-1.03.85-1.902 1.566-1.937 1.593-.043.032-.075.015-.093-.051z", fill: "#e04929" }), h$1("path", { d: "M.268 33.743c.014-.1.087-.593.163-1.097.077-.503.14-.945.14-.981 0-.036.355-.338.79-.671 1.14-.874 1.216-.928 1.245-.9.032.032.189 1.547.19 1.834.002.201-.009.21-1.254 1.1-.69.493-1.265.896-1.277.896-.012 0-.01-.081.003-.18z", fill: "#e68634" }), h$1("path", { d: "M.96 29.82c0-.021.114-.475.253-1.01l.253-.97.34-.384c.187-.21.35-.374.36-.362.012.01.086.388.166.838.13.736.136.826.058.886-.86.66-1.37 1.041-1.396 1.041-.019 0-.034-.017-.034-.039z", fill: "#e29d39" }), h$1("path", { d: "M75.479 28.954c-.139-.2-.322-.805-.263-.865.008-.008.08.07.158.173.133.175.356.854.299.911-.015.014-.102-.084-.194-.219z", fill: "#deb857" }), h$1("path", { d: "M35.096 21.356c-2.466-3.787-4.488-6.924-4.495-6.973-.007-.049 1.473-3.22 3.288-7.05l3.3-6.96.721-.19c.676-.18.772-.19 1.502-.18 1.16.017 2.476.114 2.728.202.123.043.549.145.947.228.516.108.759.184.845.268.067.064.583.711 1.146 1.437l1.024 1.32 1.638 1.47 1.637 1.469 1.21 4.84 1.208 4.84-6.08 6.083c-3.344 3.346-6.093 6.083-6.108 6.082-.016 0-2.045-3.1-4.511-6.886z", fill: "#e29d39" }), h$1("path", { d: "M6.473 17.383c0-.332.555-1.212 1.635-2.594.374-.478.76-.825.76-.683 0 .124-.52 1.972-.573 2.041-.03.039-.296.237-.59.44-.295.203-.693.48-.884.616-.191.136-.348.217-.348.18z", fill: "#e68634" }), h$1("path", { d: "M69.14 15.824c-.501-.237-.461-.173-.607-.964-.036-.2-.032-.21.067-.147.125.078 1.095 1.354 1.011 1.33-.01-.002-.221-.1-.471-.219z", fill: "#d9ad3d" }), h$1("path", { d: "M9.59 15.784c0-.023.18-.718.401-1.545l.403-1.504.576-.89c.318-.49.657-.975.755-1.078.233-.244 1.484-1.375 1.882-1.702l.313-.257 1.219.137c.67.075 2.458.227 3.974.338 1.515.11 2.761.207 2.768.215.01.01-3.744 5.347-3.857 5.483-.018.023-8.058.841-8.28.843-.084.001-.153-.017-.154-.04z", fill: "#e04929" }), h$1("path", { d: "M51.694 11.105a423.36 423.36 0 01-1.136-4.6c-.007-.072.525-.331 2.302-1.124l2.311-1.03.999.254c.948.242 1.032.275 1.67.65.37.219.986.603 1.369.854l.696.457.482.913.482.913.46 2.773c.266 1.612.437 2.791.408 2.816-.028.024-2.005.39-4.394.814-2.389.424-4.384.78-4.433.794-.075.02-.269-.695-1.216-4.484z", fill: "#b9bc4a" }), h$1("path", { d: "M65.195 14.61c-1.225-.324-2.24-.607-2.256-.628-.045-.064-.855-5.004-.824-5.035.015-.015.307.038.648.118l.622.146.487.423c.876.762 1.924 1.864 2.535 2.666l.6.788.223 1.016c.123.56.216 1.034.208 1.056-.008.021-1.018-.226-2.243-.55z", fill: "#a6be55" }), h$1("path", { d: "M19.522 14.8c.026-.066 3.17-4.511 5.891-8.33 1.305-1.83 1.723-2.368 2.856-3.675a312.66 312.66 0 011.396-1.605c.039-.04.418-.161.843-.267.425-.106.911-.24 1.08-.297.33-.112 1.432-.288 2.592-.413.655-.071.77-.07 1.25.018.291.053.524.12.519.15-.032.162-6.372 13.474-6.433 13.506-.04.02-2.252.24-4.917.488s-4.903.46-4.973.47c-.081.013-.12-.004-.104-.045z", fill: "#e68634" }), h$1("path", { d: "M19.702 8.216c-1.376-.104-2.514-.2-2.528-.214-.013-.014.057-.436.156-.938l.181-.912.815-.5c.968-.592 1.922-1.13 2.006-1.13.033 0 .472-.148.975-.328l.916-.327 1.611.258c.886.141 1.62.279 1.629.305.009.027-.616.935-1.39 2.019l-1.406 1.97-.231-.007c-.127-.004-1.358-.092-2.734-.196z", fill: "#e29d39" }), h$1("path", { d: "M15.477 7.877c-.148-.011-.26-.043-.25-.07.032-.094.908-.718.927-.662.011.03-.01.217-.048.415-.075.4-.009.366-.63.317zM48.726 4.34c-.661-.59-1.205-1.097-1.207-1.127-.002-.03.566-.365 1.262-.744l1.267-.688.677.226c.373.124 1.045.367 1.494.54.678.261.9.377 1.31.685.272.204.496.383.498.399.004.035-3.958 1.784-4.039 1.782-.032 0-.6-.483-1.262-1.073z", fill: "#e68634" }), h$1("path", { d: "M25.019 3.197c-.945-.156-1.174-.21-1.092-.258.056-.033.168-.114.25-.18.15-.123 1.745-.722 2.65-.997.275-.083.624-.16.774-.171l.274-.02-.111.125-.798.918c-.378.437-.702.79-.72.787-.017-.004-.57-.096-1.227-.204z", fill: "#cbb742" }), h$1("path", { d: "M46.084 1.643c-.3-.389-.568-.741-.593-.783-.093-.154.96-.046 1.986.203.516.125.962.243.993.262.047.029-1.694 1.018-1.801 1.023-.021 0-.284-.316-.585-.705z", fill: "#d9ad3d" })), h$1("div", { part: "logo-text" }, h$1("span", { style: { color: 'rgb(67, 119, 205)' } }, "N"), h$1("span", { style: { color: 'rgb(80, 151, 186)' } }, "e"), h$1("span", { style: { color: 'rgb(99, 172, 154)' } }, "x"), h$1("span", { style: { color: 'rgb(124, 184, 121)' } }, "t"), h$1("span", { style: { color: 'rgb(185, 188, 74)' } }, "c"), h$1("span", { style: { color: 'rgb(212, 177, 63)' } }, "l"), h$1("span", { style: { color: 'rgb(228, 153, 56)' } }, "a"), h$1("span", { style: { color: 'rgb(230, 112, 48)' } }, "d"), h$1("span", { style: { color: 'rgb(222, 60, 38)' } }, "e"))));
  }
  static get style() { return nxtLogoCss; }
};

var QcStatus;
(function (QcStatus) {
  QcStatus["good"] = "good";
  QcStatus["mediocre"] = "mediocre";
  QcStatus["bad"] = "bad";
})(QcStatus || (QcStatus = {}));
function convertSimpleSubToSub({ ref, pos, qry }) {
  return {
    refNuc: ref,
    pos,
    queryNuc: qry,
    aaDeletions: [],
    aaSubstitutions: [],
    pcrPrimersChanged: [],
  };
}
function convertPrivateMutations(privateNucMutations) {
  const { reversionSubstitutions, labeledSubstitutions, unlabeledSubstitutions } = privateNucMutations;
  // NOTE: Convert NucleotideDeletionSimple to NucleotideSubstitutionSimple,
  // and then everything to NucleotideSubstitutions, so that it's easier to render badge components.
  const reversions = reversionSubstitutions.map(convertSimpleSubToSub);
  const labeled = labeledSubstitutions;
  // NOTE: we ignore unlabeled deletions. There are too many of them
  // TODO: consider converting deletions to ranges, as in the "Gap" column.
  const unlabeled = unlabeledSubstitutions.map(convertSimpleSubToSub);
  const totalMutations = reversions.length + labeled.length + unlabeled.length;
  return { reversions, labeled, unlabeled, totalMutations };
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


const applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement$1(placement) {
  return placement.split('-')[0];
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
    // Fallback to 1 in case both values are `0`

    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }

    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }

  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


const arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getVariation(placement) {
  return placement.split('-')[1];
}

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


const computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


const eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement$1(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement$1(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement$1(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


const flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


const hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


const offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


const popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


const preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce$1(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

/**!
* tippy.js v6.3.7
* (c) 2017-2021 atomiks
* MIT License
*/
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
  return document.body;
};
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (obj[key] !== undefined) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

function div() {
  return document.createElement('div');
}
function isElement(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, 'NodeList');
}
function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;

  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        popperState = _ref.popperState,
        props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;

    if (!offsetData) {
      return true;
    }

    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}
/**
 * Compared to xxx.contains, this function works for dom structures with shadow
 * dom
 */

function actualContains(parent, child) {
  var target = child;

  while (target) {
    var _target$getRootNode;

    if (parent.contains(target)) {
      return true;
    }

    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }

  return false;
}

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var isIE11 = isBrowser ? // @ts-ignore
!!window.msCrypto : false;

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      var _name;

      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }

    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}

var innerHTML = function innerHTML() {
  return 'innerHTML';
};

function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}

function createArrowElement(value) {
  var arrow = div();

  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;

    if (isElement(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }

  return arrow;
}

function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);

  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        box = _getChildren.box,
        content = _getChildren.content,
        arrow = _getChildren.arrow;

    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }

    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }

    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }

    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }

    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }

    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }

  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away

render.$$tippy = true;

var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
  // 🔒 Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget; // ===========================================================================
  // 🔑 Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests —
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {

    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================


  var _props$render = props.render(instance),
      popper = _props$render.popper,
      onUpdate = _props$render.onUpdate;

  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function () {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    }
  });
  return instance; // ===========================================================================
  // 🔒 Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getIsDefaultRenderFn() {
    var _instance$props$rende;

    // @ts-ignore
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }

  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }

    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaContentAttribute() {
    var aria = instance.props.aria;

    if (!aria.content) {
      return;
    }

    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    }

    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

    if (instance.props.interactive && actualContains(popper, actualTarget)) {
      return;
    } // Clicked on the event listeners target


    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }

    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }

  function onTouchMove() {
    didTouchMove = true;
  }

  function onTouchStart() {
    didTouchMove = false;
  }

  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;

    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;

        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }

  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var _lastTriggerEvent;

    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;

      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }

      return null;
    }).filter(Boolean);

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

    if (shouldBail) {
      return;
    }

    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }

    scheduleHide(event);
  }

  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }

  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
        popperOptions = _instance$props2.popperOptions,
        placement = _instance$props2.placement,
        offset = _instance$props2.offset,
        getReferenceClientRect = _instance$props2.getReferenceClientRect,
        moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh.box;

          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];

    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }

    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }

  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }

  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    instance.state.isMounted = true;
    createPopperInstance();
  }

  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentPress();
    var delay = getDelay(true);

    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
        touchValue = _getNormalizedTouchSe[0],
        touchDelay = _getNormalizedTouchSe[1];

    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  // 🔑 Public methods
  // ===========================================================================


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {

    if (instance.state.isDestroyed) {
      return;
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed


    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();
    handleStyles();

    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }

    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show() {


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    instance.state.isVisible = true;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }

    handleStyles();
    addDocumentPress();

    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration


    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh2.box,
          content = _getDefaultTemplateCh2.content;

      setTransitionDuration([box, content], 0);
    }

    onFirstUpdate = function onFirstUpdate() {
      var _instance$popperInsta2;

      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }

      ignoreOnFirstUpdate = true; // reflow
      popper.style.transition = instance.props.moveTransition;

      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
            _box = _getDefaultTemplateCh3.box,
            _content = _getDefaultTemplateCh3.content;

        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
      // popper has been positioned for the first time

      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook('onMount', [instance]);

      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };

    mount();
  }

  function hide() {


    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false) {
      return;
    }

    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }

    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh4.box,
          content = _getDefaultTemplateCh4.content;

      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }

    handleAriaContentAttribute();
    handleAriaExpandedAttribute();

    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }

  function hideWithInteractivity(event) {

    getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }

  function unmount() {

    if (instance.state.isVisible) {
      instance.hide();
    }

    if (!instance.state.isMounted) {
      return;
    }

    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });

    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }

    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }

  function destroy() {

    if (instance.state.isDestroyed) {
      return;
    }

    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}

tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;

// every time the popper is destroyed (i.e. a new target), removing the styles
// and causing transitions to break for singletons when the console is open, but
// most notably for non-transform styles being used, `gpuAcceleration: false`.

Object.assign({}, applyStyles$1, {
  effect: function effect(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    } // intentionally return no cleanup function
    // return () => { ... }

  }
});

tippy.setDefaultProps({
  render: render
});

// import { AMINOACID_GAP } from '../constants';
const attachTooltip = async (popcorn, tooltip, showOnCreate = false) => {
  var _a;
  const instance = tippy(popcorn, {
    allowHTML: true,
    placement: 'auto',
    theme: 'material',
    delay: 0,
    duration: 0,
    content: (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.innerHTML) !== null && _a !== void 0 ? _a : '',
  });
  showOnCreate && instance.show();
  return instance;
};
function formatRange$1(begin, end) {
  const beginOne = begin + 1;
  const endOne = end + 1;
  if (endOne - beginOne < 2) {
    return beginOne.toString();
  }
  return `${beginOne}-${endOne}`;
}
function splitToRows(arr, { rowLength, maxRows }) {
  const n = arr.length;
  if (n === 0) {
    return [];
  }
  const rowSize = rowLength !== null && rowLength !== void 0 ? rowLength : Math.ceil(maxRows ? n / maxRows : 1);
  const rows = [];
  for (let i = 0;; i += rowSize) {
    const row = arr.slice(i, i + rowSize);
    rows.push(row);
    if (i > n) {
      break;
    }
  }
  return rows;
}
function negativeNumberToInfinity(x) {
  return x < 0 ? Number.POSITIVE_INFINITY : x;
}
function sortByGenes(geneOrderPreference) {
  return function sortByGenesPredicate(left, right) {
    // We want items that are not in the preference list to be sorted to the end
    const l = negativeNumberToInfinity(geneOrderPreference.indexOf(left.gene));
    const r = negativeNumberToInfinity(geneOrderPreference.indexOf(right.gene));
    return l - r;
  };
}

const isComplexType = (o) => {
    // https://jsperf.com/typeof-fn-object/5
    o = typeof o;
    return o === 'object' || o === 'function';
};
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// const stack: any[] = [];
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (nodeName, vnodeData, ...children) => {
    let child = null;
    let key = null;
    let simple = false;
    let lastSimple = false;
    let vNodeChildren = [];
    const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
            child = c[i];
            if (Array.isArray(child)) {
                walk(child);
            }
            else if (child != null && typeof child !== 'boolean') {
                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
                    child = String(child);
                }
                if (simple && lastSimple) {
                    // If the previous child was simple (string), we merge both
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                }
                else {
                    // Append a new vNode, if it's text, we create a text vNode
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        // normalize class / classname attributes
        if (vnodeData.key) {
            key = vnodeData.key;
        }
        {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class =
                    typeof classData !== 'object'
                        ? classData
                        : Object.keys(classData)
                            .filter((k) => classData[k])
                            .join(' ');
            }
        }
    }
    if (typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    {
        vnode.$key$ = key;
    }
    return vnode;
};
const newVNode = (tag, text) => {
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null,
    };
    {
        vnode.$attrs$ = null;
    }
    {
        vnode.$key$ = null;
    }
    return vnode;
};
const vdomFnUtils = {
    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
};
const convertToPublic = (node) => ({
    vattrs: node.$attrs$,
    vchildren: node.$children$,
    vkey: node.$key$,
    vname: node.$name$,
    vtag: node.$tag$,
    vtext: node.$text$,
});
const convertToPrivate = (node) => {
    if (typeof node.vtag === 'function') {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...(node.vchildren || []));
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};

const ANY = '.';
const AMINOACID_GAP = '-';
const GENE_ORDER_PREFERENCE = ['S', 'ORF1a', 'ORF1b', 'ORF3a', 'ORF6', 'ORF7a', 'ORF7b', 'ORF8', 'ORF9b', 'E', 'M', 'N'];
const GENE_MAP = [
  {
    geneName: 'E',
    start: 26244,
    end: 26472,
    strand: '+',
    frame: 0,
    length: 228,
    color: '#D9AD3D',
  },
  {
    geneName: 'M',
    start: 26522,
    end: 27191,
    strand: '+',
    frame: 2,
    length: 669,
    color: '#5097BA',
  },
  {
    geneName: 'N',
    start: 28273,
    end: 29533,
    strand: '+',
    frame: 1,
    length: 1260,
    color: '#E67030',
  },
  {
    geneName: 'ORF1a',
    start: 265,
    end: 13468,
    strand: '+',
    frame: 1,
    length: 13203,
    color: '#8EBC66',
  },
  {
    geneName: 'ORF1b',
    start: 13467,
    end: 21555,
    strand: '+',
    frame: 0,
    length: 8088,
    color: '#E59637',
  },
  {
    geneName: 'ORF3a',
    start: 25392,
    end: 26220,
    strand: '+',
    frame: 0,
    length: 828,
    color: '#AABD52',
  },
  {
    geneName: 'ORF6',
    start: 27201,
    end: 27387,
    strand: '+',
    frame: 0,
    length: 186,
    color: '#DF4327',
  },
  {
    geneName: 'ORF7a',
    start: 27393,
    end: 27759,
    strand: '+',
    frame: 0,
    length: 366,
    color: '#C4B945',
  },
  {
    geneName: 'ORF7b',
    start: 27755,
    end: 27887,
    strand: '+',
    frame: 2,
    length: 132,
    color: '#75B681',
  },
  {
    geneName: 'ORF8',
    start: 27893,
    end: 28259,
    strand: '+',
    frame: 2,
    length: 366,
    color: '#60AA9E',
  },
  {
    geneName: 'ORF9b',
    start: 28283,
    end: 28577,
    strand: '+',
    frame: 2,
    length: 294,
    color: '#D9AD3D',
  },
  {
    geneName: 'S',
    start: 21562,
    end: 25384,
    strand: '+',
    frame: 1,
    length: 3822,
    color: '#5097BA',
  },
];

function formatAAMutationWithoutGene({ refAA, codon, queryAA }) {
  // NOTE: by convention, codons are numbered starting from 1, however our arrays are 0-based
  const codonOneBased = codon + 1;
  return `${refAA}${codonOneBased}${queryAA}`;
}
function formatAAMutation({ gene, refAA, codon, queryAA }) {
  const notation = formatAAMutationWithoutGene({ refAA, codon, queryAA });
  return `${gene}:${notation}`;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/**
 * Create an error file out of errors.md for development and a simple web link to the full errors
 * in production mode.
 * @private
 */


var PolishedError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(PolishedError, _Error);

  function PolishedError(code) {
    var _this;

    {
      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
    }

    return _assertThisInitialized(_this);
  }

  return PolishedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function colorToInt(color) {
  return Math.round(color * 255);
}

function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}

function hslToRgb(hue, saturation, lightness, convert) {
  if (convert === void 0) {
    convert = convertToInt;
  }

  if (saturation === 0) {
    // achromatic
    return convert(lightness, lightness, lightness);
  } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV


  var huePrime = (hue % 360 + 360) % 360 / 60;
  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  var red = 0;
  var green = 0;
  var blue = 0;

  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }

  var lightnessModification = lightness - chroma / 2;
  var finalRed = red + lightnessModification;
  var finalGreen = green + lightnessModification;
  var finalBlue = blue + lightnessModification;
  return convert(finalRed, finalGreen, finalBlue);
}

var namedColorMap = {
  aliceblue: 'f0f8ff',
  antiquewhite: 'faebd7',
  aqua: '00ffff',
  aquamarine: '7fffd4',
  azure: 'f0ffff',
  beige: 'f5f5dc',
  bisque: 'ffe4c4',
  black: '000',
  blanchedalmond: 'ffebcd',
  blue: '0000ff',
  blueviolet: '8a2be2',
  brown: 'a52a2a',
  burlywood: 'deb887',
  cadetblue: '5f9ea0',
  chartreuse: '7fff00',
  chocolate: 'd2691e',
  coral: 'ff7f50',
  cornflowerblue: '6495ed',
  cornsilk: 'fff8dc',
  crimson: 'dc143c',
  cyan: '00ffff',
  darkblue: '00008b',
  darkcyan: '008b8b',
  darkgoldenrod: 'b8860b',
  darkgray: 'a9a9a9',
  darkgreen: '006400',
  darkgrey: 'a9a9a9',
  darkkhaki: 'bdb76b',
  darkmagenta: '8b008b',
  darkolivegreen: '556b2f',
  darkorange: 'ff8c00',
  darkorchid: '9932cc',
  darkred: '8b0000',
  darksalmon: 'e9967a',
  darkseagreen: '8fbc8f',
  darkslateblue: '483d8b',
  darkslategray: '2f4f4f',
  darkslategrey: '2f4f4f',
  darkturquoise: '00ced1',
  darkviolet: '9400d3',
  deeppink: 'ff1493',
  deepskyblue: '00bfff',
  dimgray: '696969',
  dimgrey: '696969',
  dodgerblue: '1e90ff',
  firebrick: 'b22222',
  floralwhite: 'fffaf0',
  forestgreen: '228b22',
  fuchsia: 'ff00ff',
  gainsboro: 'dcdcdc',
  ghostwhite: 'f8f8ff',
  gold: 'ffd700',
  goldenrod: 'daa520',
  gray: '808080',
  green: '008000',
  greenyellow: 'adff2f',
  grey: '808080',
  honeydew: 'f0fff0',
  hotpink: 'ff69b4',
  indianred: 'cd5c5c',
  indigo: '4b0082',
  ivory: 'fffff0',
  khaki: 'f0e68c',
  lavender: 'e6e6fa',
  lavenderblush: 'fff0f5',
  lawngreen: '7cfc00',
  lemonchiffon: 'fffacd',
  lightblue: 'add8e6',
  lightcoral: 'f08080',
  lightcyan: 'e0ffff',
  lightgoldenrodyellow: 'fafad2',
  lightgray: 'd3d3d3',
  lightgreen: '90ee90',
  lightgrey: 'd3d3d3',
  lightpink: 'ffb6c1',
  lightsalmon: 'ffa07a',
  lightseagreen: '20b2aa',
  lightskyblue: '87cefa',
  lightslategray: '789',
  lightslategrey: '789',
  lightsteelblue: 'b0c4de',
  lightyellow: 'ffffe0',
  lime: '0f0',
  limegreen: '32cd32',
  linen: 'faf0e6',
  magenta: 'f0f',
  maroon: '800000',
  mediumaquamarine: '66cdaa',
  mediumblue: '0000cd',
  mediumorchid: 'ba55d3',
  mediumpurple: '9370db',
  mediumseagreen: '3cb371',
  mediumslateblue: '7b68ee',
  mediumspringgreen: '00fa9a',
  mediumturquoise: '48d1cc',
  mediumvioletred: 'c71585',
  midnightblue: '191970',
  mintcream: 'f5fffa',
  mistyrose: 'ffe4e1',
  moccasin: 'ffe4b5',
  navajowhite: 'ffdead',
  navy: '000080',
  oldlace: 'fdf5e6',
  olive: '808000',
  olivedrab: '6b8e23',
  orange: 'ffa500',
  orangered: 'ff4500',
  orchid: 'da70d6',
  palegoldenrod: 'eee8aa',
  palegreen: '98fb98',
  paleturquoise: 'afeeee',
  palevioletred: 'db7093',
  papayawhip: 'ffefd5',
  peachpuff: 'ffdab9',
  peru: 'cd853f',
  pink: 'ffc0cb',
  plum: 'dda0dd',
  powderblue: 'b0e0e6',
  purple: '800080',
  rebeccapurple: '639',
  red: 'f00',
  rosybrown: 'bc8f8f',
  royalblue: '4169e1',
  saddlebrown: '8b4513',
  salmon: 'fa8072',
  sandybrown: 'f4a460',
  seagreen: '2e8b57',
  seashell: 'fff5ee',
  sienna: 'a0522d',
  silver: 'c0c0c0',
  skyblue: '87ceeb',
  slateblue: '6a5acd',
  slategray: '708090',
  slategrey: '708090',
  snow: 'fffafa',
  springgreen: '00ff7f',
  steelblue: '4682b4',
  tan: 'd2b48c',
  teal: '008080',
  thistle: 'd8bfd8',
  tomato: 'ff6347',
  turquoise: '40e0d0',
  violet: 'ee82ee',
  wheat: 'f5deb3',
  white: 'fff',
  whitesmoke: 'f5f5f5',
  yellow: 'ff0',
  yellowgreen: '9acd32'
};
/**
 * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
 * @private
 */

function nameToHex(color) {
  if (typeof color !== 'string') return color;
  var normalizedColorName = color.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
}

var hexRegex = /^#[a-fA-F0-9]{6}$/;
var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
var rgbRegex = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i;
var rgbaRegex = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
var hslaRegex = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
/**
 * Returns an RgbColor or RgbaColor object. This utility function is only useful
 * if want to extract a color component. With the color util `toColorString` you
 * can convert a RgbColor or RgbaColor object back to a string.
 *
 * @example
 * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
 * const color1 = parseToRgb('rgb(255, 0, 0)');
 * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
 * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
 */

function parseToRgb(color) {
  if (typeof color !== 'string') {
    throw new PolishedError(3);
  }

  var normalizedColor = nameToHex(color);

  if (normalizedColor.match(hexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
    };
  }

  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
      alpha: alpha
    };
  }

  if (normalizedColor.match(reducedHexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
    };
  }

  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));

    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha
    };
  }

  var rgbMatched = rgbRegex.exec(normalizedColor);

  if (rgbMatched) {
    return {
      red: parseInt("" + rgbMatched[1], 10),
      green: parseInt("" + rgbMatched[2], 10),
      blue: parseInt("" + rgbMatched[3], 10)
    };
  }

  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));

  if (rgbaMatched) {
    return {
      red: parseInt("" + rgbaMatched[1], 10),
      green: parseInt("" + rgbaMatched[2], 10),
      blue: parseInt("" + rgbaMatched[3], 10),
      alpha: parseFloat("" + rgbaMatched[4])
    };
  }

  var hslMatched = hslRegex.exec(normalizedColor);

  if (hslMatched) {
    var hue = parseInt("" + hslMatched[1], 10);
    var saturation = parseInt("" + hslMatched[2], 10) / 100;
    var lightness = parseInt("" + hslMatched[3], 10) / 100;
    var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
    var hslRgbMatched = rgbRegex.exec(rgbColorString);

    if (!hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, rgbColorString);
    }

    return {
      red: parseInt("" + hslRgbMatched[1], 10),
      green: parseInt("" + hslRgbMatched[2], 10),
      blue: parseInt("" + hslRgbMatched[3], 10)
    };
  }

  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));

  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10);

    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;

    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;

    var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";

    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);

    if (!_hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    }

    return {
      red: parseInt("" + _hslRgbMatched[1], 10),
      green: parseInt("" + _hslRgbMatched[2], 10),
      blue: parseInt("" + _hslRgbMatched[3], 10),
      alpha: parseFloat("" + hslaMatched[4])
    };
  }

  throw new PolishedError(5);
}

/**
 * Reduces hex values if possible e.g. #ff8866 to #f86
 * @private
 */
var reduceHexValue = function reduceHexValue(value) {
  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
    return "#" + value[1] + value[3] + value[5];
  }

  return value;
};

var reduceHexValue$1 = reduceHexValue;

function numberToHex(value) {
  var hex = value.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}

/**
 * Returns a string value for the color. The returned result is the smallest possible hex notation.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: rgb(255, 205, 100),
 *   background: rgb({ red: 255, green: 205, blue: 100 }),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${rgb(255, 205, 100)};
 *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "#ffcd64";
 *   background: "#ffcd64";
 * }
 */
function rgb(value, green, blue) {
  if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
    return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  } else if (typeof value === 'object' && green === undefined && blue === undefined) {
    return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  }

  throw new PolishedError(6);
}

/**
 * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
 *
 * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: rgba(255, 205, 100, 0.7),
 *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
 *   background: rgba(255, 205, 100, 1),
 *   background: rgba('#ffffff', 0.4),
 *   background: rgba('black', 0.7),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${rgba(255, 205, 100, 0.7)};
 *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
 *   background: ${rgba(255, 205, 100, 1)};
 *   background: ${rgba('#ffffff', 0.4)};
 *   background: ${rgba('black', 0.7)};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "rgba(255,205,100,0.7)";
 *   background: "rgba(255,205,100,0.7)";
 *   background: "#ffcd64";
 *   background: "rgba(255,255,255,0.4)";
 *   background: "rgba(0,0,0,0.7)";
 * }
 */
function rgba(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue === 'string' && typeof secondValue === 'number') {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
  } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }

  throw new PolishedError(7);
}

// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
// eslint-disable-next-line no-unused-vars
// eslint-disable-next-line no-unused-vars
// eslint-disable-next-line no-redeclare
function curried(f, length, acc) {
  return function fn() {
    // eslint-disable-next-line prefer-rest-params
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
  };
} // eslint-disable-next-line no-redeclare


function curry(f) {
  // eslint-disable-line no-redeclare
  return curried(f, f.length, []);
}

/**
 * Returns a number (float) representing the luminance of a color.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',
 *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?
 *                             'rgba(58, 133, 255, 1)' :
 *                             'rgba(255, 57, 149, 1)',
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};
 *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?
 *                             'rgba(58, 133, 255, 1)' :
 *                             'rgba(255, 57, 149, 1)'};
 *
 * // CSS in JS Output
 *
 * div {
 *   background: "#CCCD64";
 *   background: "rgba(58, 133, 255, 1)";
 * }
 */

function getLuminance(color) {
  if (color === 'transparent') return 0;
  var rgbColor = parseToRgb(color);

  var _Object$keys$map = Object.keys(rgbColor).map(function (key) {
    var channel = rgbColor[key] / 255;
    return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
  }),
      r = _Object$keys$map[0],
      g = _Object$keys$map[1],
      b = _Object$keys$map[2];

  return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));
}

/**
 * Returns the contrast ratio between two colors based on
 * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).
 *
 * @example
 * const contrastRatio = getContrast('#444', '#fff');
 */

function getContrast(color1, color2) {
  var luminance1 = getLuminance(color1);
  var luminance2 = getLuminance(color2);
  return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));
}

/**
 * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: mix(0.5, '#f00', '#00f')
 *   background: mix(0.25, '#f00', '#00f')
 *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${mix(0.5, '#f00', '#00f')};
 *   background: ${mix(0.25, '#f00', '#00f')};
 *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "#7f007f";
 *   background: "#3f00bf";
 *   background: "rgba(63, 0, 191, 0.75)";
 * }
 */

function mix(weight, color, otherColor) {
  if (color === 'transparent') return otherColor;
  if (otherColor === 'transparent') return color;
  if (weight === 0) return otherColor;
  var parsedColor1 = parseToRgb(color);

  var color1 = _extends({}, parsedColor1, {
    alpha: typeof parsedColor1.alpha === 'number' ? parsedColor1.alpha : 1
  });

  var parsedColor2 = parseToRgb(otherColor);

  var color2 = _extends({}, parsedColor2, {
    alpha: typeof parsedColor2.alpha === 'number' ? parsedColor2.alpha : 1
  }); // The formula is copied from the original Sass implementation:
  // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method


  var alphaDelta = color1.alpha - color2.alpha;
  var x = parseFloat(weight) * 2 - 1;
  var y = x * alphaDelta === -1 ? x : x + alphaDelta;
  var z = 1 + x * alphaDelta;
  var weight1 = (y / z + 1) / 2.0;
  var weight2 = 1 - weight1;
  var mixedColor = {
    red: Math.floor(color1.red * weight1 + color2.red * weight2),
    green: Math.floor(color1.green * weight1 + color2.green * weight2),
    blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),
    alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))
  };
  return rgba(mixedColor);
} // prettier-ignore


var curriedMix = /*#__PURE__*/curry
/* ::<number | string, string, string, string> */
(mix);
var mix$1 = curriedMix;

/**
 * Shades a color by mixing it with black. `shade` can produce
 * hue shifts, where as `darken` manipulates the luminance channel and therefore
 * doesn't produce hue shifts.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: shade(0.25, '#00f')
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${shade(0.25, '#00f')};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "#00003f";
 * }
 */

function shade(percentage, color) {
  if (color === 'transparent') return color;
  return mix$1(parseFloat(percentage), 'rgb(0, 0, 0)', color);
} // prettier-ignore


var curriedShade = /*#__PURE__*/curry
/* ::<number | string, string, string> */
(shade);
var curriedShade$1 = curriedShade;

const NUCLEOTIDE_COLORS = {
  // 'A': '#B54330',
  // 'C': '#3C5BD6',
  // 'G': '#9C8D1C',
  // 'T': '#409543',
  // 'N': '#555555',
  // '-': '#777777',
  'A': '#bf2b18',
  'C': '#162ebc',
  'G': '#bcaf27',
  'T': '#18b924',
  'N': '#555555',
  '-': '#777777',
};
function getNucleotideColor(nuc) {
  var _a;
  return (_a = NUCLEOTIDE_COLORS === null || NUCLEOTIDE_COLORS === void 0 ? void 0 : NUCLEOTIDE_COLORS[nuc]) !== null && _a !== void 0 ? _a : NUCLEOTIDE_COLORS.N;
}

// Borrowed from http://ugene.net/forum/YaBB.pl?num=1337064665
const AMINOACID_COLORS = {
  'A': '#e5e575',
  'V': '#e5e57c',
  'L': '#e5e550',
  'I': '#e5e514',
  'B': '#e54c4c',
  'C': '#cee599',
  'D': '#e5774e',
  'E': '#e59c6c',
  'F': '#e2e54d',
  'G': '#e57474',
  'H': '#9ddde5',
  'K': '#b4a2e5',
  'M': '#b7e525',
  'N': '#e57875',
  'P': '#b6b5e5',
  'Q': '#e5aacd',
  'R': '#878fe5',
  'S': '#e583d8',
  'T': '#e5b3cc',
  'W': '#4aa7e5',
  'X': '#aaaaaa',
  'Y': '#57cfe5',
  'Z': '#777777',
  '*': '#777777',
  '-': '#444444',
};
function getAminoacidColor(aa) {
  var _a;
  return (_a = AMINOACID_COLORS === null || AMINOACID_COLORS === void 0 ? void 0 : AMINOACID_COLORS[aa]) !== null && _a !== void 0 ? _a : AMINOACID_COLORS['-'];
}

function getTextColor(theme, backgroundColor) {
  const contrast = getContrast(backgroundColor, theme.gray100);
  if (contrast > 3) {
    return theme.gray100;
  }
  return theme.gray800;
}

const gridBreakpoints = {
  xs: '0',
  sm: '576px',
  md: '768px',
  lg: '992px',
  xl: '1200px',
  xxl: '2000px',
};
const containerMaxWidths = {
  sm: '540px',
  md: '720px',
  lg: '960px',
  xl: '1140px',
  xxl: '1950px',
};
const transparent = '#ffffff00';
const white = '#ffffff';
const gray100 = '#f8f9fa';
const gray150 = '#eff1f3';
const gray200 = '#e9ecef';
const gray250 = '#e5e8ea';
const gray300 = '#dee2e6';
const gray400 = '#ced4da';
const gray500 = '#adb5bd';
const gray550 = '#979fa7';
const gray600 = '#7b838a';
const gray650 = '#626a71';
const gray700 = '#495057';
const gray800 = '#343a40';
const gray900 = '#212529';
const black = '#000';
const blue = '#2196f3';
const indigo = '#6610f2';
const purple = '#6f42c1';
const pink = '#e83e8c';
const red = '#e51c23';
const orange = '#fd7e14';
const yellow = '#ff9800';
const green = '#4caf50';
const teal = '#20c997';
const cyan = '#9c27b0';
const primary = blue;
const secondary = gray100;
const success = green;
const info = cyan;
const warning = yellow;
const danger = red;
const light = white;
const dark = gray700;
const basicColors = {
  transparent,
  white,
  gray100,
  gray150,
  gray200,
  gray250,
  gray300,
  gray400,
  gray500,
  gray550,
  gray600,
  gray650,
  gray700,
  gray800,
  gray900,
  black,
  blue,
  indigo,
  purple,
  pink,
  red,
  orange,
  yellow,
  green,
  teal,
  cyan,
};
const themeColors = {
  primary,
  secondary,
  success,
  info,
  warning,
  danger,
  light,
  dark,
};
const font = {
  sansSerif: `'Lato', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Helvetica Neue', 'Arial', 'system-ui', 'system-sans', 'sans-serif'`,
  monospace: `'Roboto Mono', system-mono, sans-serif`,
  default: 'sans-serif',
};
const shadows = {
  light: `1px 1px 1px 1px ${rgba(gray600, 0.2)}`,
  slight: `1px 1px 1px 1px ${rgba(gray700, 0.25)}`,
  medium: `2px 2px 3px 3px ${rgba(gray900, 0.25)}`,
  filter: {
    slight: `1px 1px 1px ${rgba(gray700, 0.25)}`,
    medium: `2px 2px 3px ${rgba(gray900, 0.33)}`,
  },
};
const uploadZoneBxoShadow = `1px 1px 3px 3px ${rgba(gray700, 0.25)}`;
const filePicker = {
  minHeight: '200px',
  borderRadius: '5px',
  border: {
    normal: `4px ${rgba(basicColors.gray500, 0.33)} solid`,
  },
};
const uploadZone = {
  'background': {
    normal: basicColors.transparent,
    accept: rgba(themeColors.success, 0.25),
    reject: rgba(themeColors.danger, 0.25),
    hover: basicColors.transparent,
  },
  'color': {
    normal: basicColors.gray700,
    accept: themeColors.success,
    reject: themeColors.danger,
    hover: basicColors.gray900,
  },
  'border': {
    normal: `4px ${rgba(basicColors.gray500, 0.75)} dashed`,
    accept: `4px ${rgba(themeColors.success, 0.75)} dashed`,
    reject: `4px ${rgba(themeColors.danger, 0.75)} dashed`,
    hover: `4px ${rgba(basicColors.gray550, 0.75)} dashed`,
  },
  'box-shadow': {
    normal: 'none',
    accept: uploadZoneBxoShadow,
    reject: uploadZoneBxoShadow,
    hover: uploadZoneBxoShadow,
  },
};
const theme = Object.assign(Object.assign(Object.assign(Object.assign({ bodyColor: basicColors.gray700, bodyBg: basicColors.white }, basicColors), themeColors), gridBreakpoints), { containerMaxWidths,
  font,
  shadows,
  filePicker,
  uploadZone });

const MutationBadgeBox = (_, children) => (h("span", { class: "MutationBadgeBox", style: {
    display: 'inline-block',
    fontSize: '0.75rem',
  } }, ...children));
const MutationWrapper = (_, children) => (h("span", { class: "MutationWrapper", style: {
    borderRadius: '2px',
    boxShadow: theme.shadows.light,
    fontFamily: theme.font.monospace,
  } }, ...children));
const GeneText = (props, children) => (h("span", { class: "GeneText", style: Object.assign({
    padding: '1px 2px',
    color: theme.gray100,
    fontWeight: '700',
  }, props) }, ...children));
const ColoredText = (props, children) => (h("span", { class: "ColoredText", style: Object.assign({
    padding: '1px 2px',
    color: theme.black,
    fontWeight: '700',
  }, props) }, ...children));
const PositionText = (props, children) => (h("span", { class: "PositionText", style: Object.assign({
    padding: '1px 2px',
    backgroundColor: theme.gray300,
    color: theme.gray800,
  }, props) }, ...children));
function NucleotideMutationBadge({ mutation }) {
  const { refNuc, pos, queryNuc } = mutation;
  const refBg = curriedShade$1(0.25)(getNucleotideColor(refNuc));
  const refFg = getTextColor(theme, refBg);
  const queryBg = curriedShade$1(0.25)(getNucleotideColor(queryNuc));
  const queryFg = getTextColor(theme, queryBg);
  const posOneBased = pos + 1;
  return (h(MutationBadgeBox, null,
    h(MutationWrapper, null,
      refNuc && (h(ColoredText, { backgroundColor: refBg, color: refFg }, refNuc)),
      pos && h(PositionText, null, posOneBased),
      queryNuc && (h(ColoredText, { backgroundColor: queryBg, color: queryFg }, queryNuc)))));
}
function AminoacidMutationBadge({ mutation, geneMap }) {
  var _a, _b;
  const { gene: geneName, refAA, codon } = mutation;
  const queryAA = ((_a = mutation['queryAA']) !== null && _a !== void 0 ? _a : AMINOACID_GAP);
  const gene = geneMap.find(gene => gene.geneName === geneName);
  const geneBg = (_b = gene === null || gene === void 0 ? void 0 : gene.color) !== null && _b !== void 0 ? _b : '#999';
  const refBg = getAminoacidColor(refAA);
  const refFg = getTextColor(theme, refBg);
  const queryBg = getAminoacidColor(queryAA);
  const queryFg = getTextColor(theme, queryBg);
  const codonOneBased = codon + 1;
  return (h(MutationBadgeBox, null,
    h(MutationWrapper, null,
      h(GeneText, { backgroundColor: geneBg },
        geneName,
        h("span", null, ':')),
      h(ColoredText, { backgroundColor: refBg, color: refFg }, refAA),
      h(PositionText, null, codonOneBased),
      h(ColoredText, { backgroundColor: queryBg, color: queryFg }, queryAA))));
}

function ListOfAminoacidSubstitutions({ aminoacidSubstitutions }) {
  const totalMutations = aminoacidSubstitutions.length;
  const maxRows = Math.min(8, totalMutations);
  const numCols = 8;
  const substitutionsSelected = [...aminoacidSubstitutions].sort(sortByGenes(GENE_ORDER_PREFERENCE)).slice(0, maxRows * numCols);
  const columns = splitToRows(substitutionsSelected, { maxRows });
  let moreText;
  if (totalMutations > substitutionsSelected.length) {
    moreText = '(truncated)';
  }
  return (h("div", { class: "d-flex" },
    h("div", { class: "mr-auto" },
      h("table", null,
        h("tbody", null,
          columns.map((col, i) => (h("tr", { key: i }, col.map(item => (h("td", { key: formatAAMutation(item) },
            h(AminoacidMutationBadge, { mutation: item, geneMap: GENE_MAP }))))))),
          moreText && (h("tr", null,
            h("td", { colSpan: maxRows, class: "text-center" }, moreText))))))));
}

function ListOfMutationsGeneric({ substitutions }) {
  const totalMutations = substitutions.length;
  const maxRows = Math.min(8, totalMutations);
  const numCols = 8;
  const substitutionsSelected = substitutions.slice(0, maxRows * numCols);
  const columns = splitToRows(substitutionsSelected, { rowLength: maxRows });
  let moreText;
  if (totalMutations > substitutionsSelected.length) {
    moreText = '(truncated)';
  }
  return (h("div", { class: "d-flex" },
    h("div", { class: "mr-auto" },
      h("table", null,
        h("tbody", null,
          columns.map((col, i) => (
          // eslint-disable-next-line react/no-array-index-key
          h("tr", { key: i }, col.map(item => (h("td", { key: item.pos },
            h(NucleotideMutationBadge, { mutation: item }))))))),
          moreText && (h("tr", null,
            h("td", { colSpan: numCols, class: "text-center" }, moreText))))))));
}

const MutationLabelBadge = (_, children) => (h("span", { class: "MutationBadgeBox", style: {
    backgroundColor: theme.gray300,
    borderRadius: '3px',
    boxShadow: theme.shadows.slight,
    margin: '3px 5px',
    padding: '0 3px',
    fontFamily: theme.font.monospace,
  } }, ...children));
function MutationLabelBadgeComponent({ label }) {
  return h(MutationLabelBadge, null, label);
}
function ListOfMutationsLabeled({ mutationsLabeled }) {
  const labeledMutationRows = () => mutationsLabeled.map(({ substitution, labels }) => {
    const substitutionConverted = convertSimpleSubToSub(substitution);
    let labelsTruncated = Array.from(new Set(labels));
    let labelsTruncatedStr = '';
    if (labels.length > 6) {
      labelsTruncated = labels.slice(0, 7);
      labelsTruncatedStr = ', ...more';
    }
    const labelComponents = labelsTruncated.map(label => h(MutationLabelBadgeComponent, { label: label }));
    return (h("tr", { key: substitutionConverted.pos },
      h("td", null,
        h(NucleotideMutationBadge, { mutation: substitutionConverted })),
      h("td", null,
        h("span", null, labelComponents),
        h("span", null, labelsTruncatedStr))));
  });
  return (h("div", { class: "d-flex" },
    h("div", { class: "mr-auto" },
      h("table", null,
        h("thead", null,
          h("tr", null,
            h("th", null, "Mutation"),
            h("th", null, "Labels"))),
        h("tbody", null, labeledMutationRows())))));
}

function ListOfPrivateNucMutations({ privateNucMutationsInternal }) {
  const { reversions, labeled, unlabeled } = privateNucMutationsInternal;
  return (h("div", { class: "d-flex" },
    h("div", { class: "mr-auto" },
      h("ul", { style: { paddingLeft: '0' }, class: "pl-2" },
        reversions.length > 0 && (h("li", { style: { listStyle: 'none' } },
          h("table", { class: "mb-0" },
            h("tbody", null,
              h("tr", null,
                h("td", null, `Reversions (${reversions.length})`)),
              h("tr", null,
                h("td", null,
                  h(ListOfMutationsGeneric, { substitutions: reversions }))))))),
        labeled.length > 0 && (h("li", { style: { listStyle: 'none' } },
          h("table", { class: "mb-0" },
            h("tbody", null,
              h("tr", null,
                h("td", null, `Labelled private mutations (${labeled.length})`)),
              h("tr", null,
                h("td", null,
                  h(ListOfMutationsLabeled, { mutationsLabeled: labeled }))))))),
        unlabeled.length > 0 && (h("li", { style: { listStyle: 'none' } },
          h("table", { class: "mb-0" },
            h("tbody", null,
              h("tr", null,
                h("td", null, `Unlabelled private mutations (${unlabeled.length})`)),
              h("tr", null,
                h("td", null,
                  h(ListOfMutationsGeneric, { substitutions: unlabeled })))))))))));
}

const nxtMutationsCss = ":host{display:table-cell;vertical-align:middle;text-align:center}:host .MutationWrapper>span:first-child{padding-left:4px;border-top-left-radius:3px;border-bottom-left-radius:3px}:host .MutationWrapper>span:last-child{padding-right:4px;border-top-right-radius:3px;border-bottom-right-radius:3px}:host .tippy-box{max-width:fit-content !important}:host nxt-tip table{text-align:left}:host nxt-tip table tr th{padding:0.5 0.5rem 0}:host nxt-tip table tr td{padding:0 1rem}:host .d-flex{display:flex}:host .mr-auto{flex:1 1 auto}:host .mr-auto table{width:100%;text-align:left}:host .mr-auto table th{text-align:left}:host .mr-auto table td{padding:0 0.5rem}:host .mr-auto table tr{margin:0;padding:0}:host .mr-auto table th{margin:0;padding:0 0.5rem}";

let NxtMutations$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.open = false;
  }
  async connectedCallback() {
    if (this.tooltip === undefined) {
      this.tooltip = await attachTooltip(this.hostEl, null, false);
    }
  }
  async componentDidLoad() {
    this.tooltip.setProps({
      content: this.divEl.innerHTML,
      appendTo: this.spanEl,
      interactive: true,
      touch: 'hold',
    });
  }
  render() {
    const { substitutions, aaSubstitutions, privateNucMutations } = this.data;
    const privateNucMutationsInternal = convertPrivateMutations(privateNucMutations);
    return (h$1(Host, null, h$1("span", { ref: init => (this.spanEl = init) }, h$1("slot", null)), h$1("div", { ref: init => (this.divEl = init), style: { display: this.open ? 'block' : 'none' } }, h$1("nxt-tip", null, h$1("table", null, h$1("thead", null), h$1("tbody", null, h$1("tr", null, h$1("th", null, `Nucleotide substitutions rel. to reference (${substitutions.length})`)), h$1("tr", null, h$1("td", null, h$1(ListOfMutationsGeneric, { substitutions: substitutions }))), h$1("tr", null, h$1("th", null, `Aminoacid substitutions rel. to reference (${aaSubstitutions.length})`)), h$1("tr", null, h$1("td", null, h$1(ListOfAminoacidSubstitutions, { aminoacidSubstitutions: aaSubstitutions }))), h$1("tr", null, h$1("th", null, `Private mutations rel. to tree (${privateNucMutationsInternal.totalMutations})`)), h$1("tr", null, h$1("td", null, h$1(ListOfPrivateNucMutations, { privateNucMutationsInternal: privateNucMutationsInternal })))))))));
  }
  get hostEl() { return this; }
  static get style() { return nxtMutationsCss; }
};

function notUndefined(x) {
  return x !== undefined;
}
function notUndefinedOrNull(x) {
  return x !== undefined && x !== null;
}

function formatRange(begin, end) {
  if (begin >= end) {
    console.warn(`formatRange: Attempted to format an invalid range: '[${begin}; ${end}]'. This is probably a bug.`);
    return 'empty range';
  }
  // NOTE: we (and JavaScript) use 0-based, half-open ranges,
  // but bioinformaticians prefer 1-based, closed ranges.
  // So we convert from "0-based, half-open ranges" to "1-based, closed ranges" here
  const beginOne = begin + 1;
  const endOne = end;
  if (endOne === beginOne) {
    return beginOne.toString();
  }
  return `${beginOne}-${endOne}`;
}

function formatFrameShift(frameShift) {
  const { geneName, codon } = frameShift;
  const { begin, end } = codon;
  return `${geneName}:${formatRange(begin, end)}`;
}

function formatQCFrameShifts(qcFrameShifts) {
  if (!notUndefinedOrNull(qcFrameShifts)) {
    return undefined;
  }
  const { score, frameShifts, totalFrameShifts, frameShiftsIgnored, totalFrameShiftsIgnored } = qcFrameShifts;
  const frameShiftsList = frameShifts.map(frameShift => formatFrameShift(frameShift)).join(', ');
  const frameShiftsIgnoredList = frameShiftsIgnored.map(frameShift => formatFrameShift(frameShift)).join(', ');
  let unexpected;
  if (frameShiftsList.length > 0) {
    unexpected = `Unexpected ${totalFrameShifts} frame shift(s) detected: ${frameShiftsList}`;
  }
  let ignored;
  if (frameShiftsIgnoredList.length > 0) {
    ignored = `Ignored ${totalFrameShiftsIgnored} known frame shift(s): ${frameShiftsIgnoredList}`;
  }
  let scoreStr;
  if (notUndefined(unexpected || ignored)) {
    scoreStr = `QC score: ${score}`;
  }
  return [unexpected, ignored, scoreStr].filter(notUndefined).join('. ');
}

function formatQCMissingData(missingData) {
  if (missingData === undefined || missingData.status === QcStatus.good) {
    return undefined;
  }
  const { score, totalMissing, missingDataThreshold, status } = missingData;
  let message = 'Missing data found';
  if (status === QcStatus.bad) {
    message = 'Too much missing data found';
  }
  return `${message}. Total Ns: ${totalMissing} (${missingDataThreshold} allowed). QC score: ${Math.round(score)}`;
}

function formatQCMixedSites(mixedSites) {
  if (mixedSites === undefined || mixedSites.status === QcStatus.good) {
    return undefined;
  }
  const { score, totalMixedSites, mixedSitesThreshold, status } = mixedSites;
  let message = 'Mixed sites found';
  if (status === QcStatus.bad) {
    message = 'Too many mixed sites found';
  }
  return `${message}: total ${totalMixedSites} (${mixedSitesThreshold} allowed). QC score: ${Math.round(score)}`;
}

function formatQCPrivateMutations(privateMutations) {
  if (privateMutations === undefined || privateMutations.status === QcStatus.good) {
    return undefined;
  }
  const { score, numReversionSubstitutions, numLabeledSubstitutions, numUnlabeledSubstitutions, totalDeletionRanges, weightedTotal } = privateMutations;
  return `QC score: ${Math.round(score)}.
      Reverted substitutions: ${numReversionSubstitutions},
      Labeled substitutions: ${numLabeledSubstitutions},
      Unlabelled substitutions: ${numUnlabeledSubstitutions},
      Deletion ranges: ${totalDeletionRanges}.
      Weighted total: ${weightedTotal}`;
}

function formatQCSNPClusters(snpClusters) {
  if (snpClusters === undefined || snpClusters.status === QcStatus.good) {
    return undefined;
  }
  const { score, totalSNPs, status } = snpClusters;
  let message = 'Mutation clusters found';
  if (status === QcStatus.bad) {
    message = 'Too many mutation clusters found';
  }
  return `${message}. Seen ${snpClusters.clusteredSNPs.length} mutation clusters with total of ${totalSNPs} mutations. QC score: ${Math.round(score)}`;
}

function formatQCStopCodons(qcStopCodons) {
  if (!notUndefinedOrNull(qcStopCodons) || qcStopCodons.status === QcStatus.good) {
    return undefined;
  }
  const { score, stopCodons, totalStopCodons } = qcStopCodons;
  const geneList = [...new Set(stopCodons.map(({ geneName }) => geneName))].join(', ');
  return `${totalStopCodons} misplaced stop codon(s) detected. Affected gene(s): ${geneList}. QC score: ${score}`;
}

function QcListItem({ status, text }, children) {
  return (h("li", { style: {
      listStyle: 'none',
      display: 'flex',
      padding: '0.25rem 0',
    } },
    h("span", { style: { marginRight: '1rem' } },
      h("nxt-circle", { status: status }, text)),
    h("span", null, children)));
}
function ListOfQcIssues({ qc }) {
  const { overallScore, overallStatus, privateMutations, snpClusters, mixedSites, missingData, frameShifts, stopCodons } = qc;
  const rules = [
    { name: 'Missing Data', shortName: 'N', value: missingData, message: formatQCMissingData(missingData) },
    { name: 'Mixed Sites', shortName: 'M', value: mixedSites, message: formatQCMixedSites(mixedSites) },
    { name: 'Private Mutations', shortName: 'P', value: privateMutations, message: formatQCPrivateMutations(privateMutations) },
    { name: 'Mutation Clusters', shortName: 'C', value: snpClusters, message: formatQCSNPClusters(snpClusters) },
    { name: 'Frame shifts', shortName: 'F', value: frameShifts, message: formatQCFrameShifts(frameShifts) },
    { name: 'Stop codons', shortName: 'S', value: stopCodons, message: formatQCStopCodons(stopCodons) },
  ].filter(value => value !== undefined);
  const issues = rules.map(({ name, shortName, value, message }) => {
    if (!value) {
      return undefined;
    }
    return (h(QcListItem, { status: value.status, text: shortName },
      h("div", null,
        h("span", null,
          h("b", null, name)),
        h("span", null, ': '),
        h("span", null, value.status)), message !== null && message !== void 0 ? message : 'No issues'));
  });
  return (h("div", null,
    h("div", null, `Overall QC score: ${Math.round(overallScore)}`),
    h("div", null, `Overall QC status: ${overallStatus}`),
    h("div", null,
      'Detailed QC assessment:',
      h("ul", { style: {
          paddingInlineStart: '0',
        } }, issues))));
}

const nxtQcCss = ":host{display:inline-flex}";

let NxtQc$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.open = false;
  }
  async componentDidLoad() {
    attachTooltip(this.hostEl, this.divEl, false);
  }
  renderStatusDiscs() {
    const { missingData, privateMutations, mixedSites, snpClusters, frameShifts, stopCodons } = this.data;
    const rules = [
      { value: missingData, name: 'N' },
      { value: mixedSites, name: 'M' },
      { value: privateMutations, name: 'P' },
      { value: snpClusters, name: 'C' },
      { value: frameShifts, name: 'F' },
      { value: stopCodons, name: 'S' },
    ].filter(value => value !== undefined);
    return rules.map(({ name, value }) => h$1("nxt-circle", { status: value.status }, name));
  }
  render() {
    return (h$1(Host, null, this.renderStatusDiscs(), h$1("div", { ref: init => (this.divEl = init), style: { display: this.open ? 'block' : 'none' } }, h$1("nxt-tip", null, h$1(ListOfQcIssues, { qc: Object.assign({}, this.data) })))));
  }
  get hostEl() { return this; }
  static get style() { return nxtQcCss; }
};

const nxtRowCss = ":host{display:table-row}:host>td{padding:0.2rem;width:1vw;white-space:nowrap;vertical-align:middle;text-align:center}:host>td.truncate-text{text-overflow:ellipsis;overflow:hidden;width:10vw;max-width:15rem}:host>td.truncate-text:hover{text-overflow:unset;overflow:visible;word-wrap:break-word;white-space:normal;padding:0 0.2rem}:host>td:first-of-type{text-align:left}:host>nxt-sequence{height:2.05rem;width:100%}:host([status=mediocre]){background-color:#f6edcb}:host([status=bad]){background-color:#edcbcb}:host([status=hasErrors]){background-color:#f0a9a9}:host([status=hasErrors])>td{padding:0.2rem;height:1.7rem}:host([status=hasErrors])>td[colSpan]{color:#962d26;text-align:center;text-transform:uppercase}";

const MAX_COLUMNS = 10;
let NxtRow$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.data = null;
    this.summary = false;
    this.hiddenColumns = [];
  }
  renderFrameShifts(qc) {
    const { totalFrameShifts, totalFrameShiftsIgnored } = qc.frameShifts;
    const grandTotal = totalFrameShiftsIgnored + totalFrameShifts;
    return grandTotal === 0 ? '0' : `${totalFrameShifts} (${grandTotal})`;
  }
  renderStats() {
    const { seqName, qc, clade, totalNonACGTNs, totalMissing, totalDeletions, totalInsertions, totalSubstitutions, missing, deletions, substitutions, alignmentStart, alignmentEnd, } = this.data;
    return [
      h$1("td", { class: "truncate-text" }, seqName),
      h$1("td", null, h$1("nxt-qc", { data: qc })),
      h$1("td", null, clade),
      h$1("nxt-mutations", { data: this.data }, totalSubstitutions),
      h$1("td", null, totalNonACGTNs),
      h$1("td", null, totalMissing),
      h$1("td", null, totalDeletions),
      h$1("td", null, totalInsertions),
      h$1("td", null, this.renderFrameShifts(qc)),
      this.summary === false ? h$1("nxt-sequence", Object.assign({}, { substitutions, missing, deletions, alignmentStart, alignmentEnd, genomeSize: this.genomeSize })) : null,
    ].filter((_, i) => !this.hiddenColumns.includes(i));
  }
  renderErrors() {
    const { seqName, errors } = this.data;
    const columnsShownCount = MAX_COLUMNS - this.hiddenColumns.length;
    switch (columnsShownCount) {
      case 0:
        return null;
      case 1:
        return (h$1("td", { colSpan: columnsShownCount }, h$1("span", { style: { textTransform: 'initial' } }, seqName), ": ", errors.join(', ')));
      default:
        return [h$1("td", null, seqName), h$1("td", { colSpan: columnsShownCount - 1 }, errors.join(', '))];
    }
  }
  render() {
    if (this.data === null) {
      return;
    }
    const { qc, errors = [] } = this.data;
    return h$1(Host, { status: (qc === null || qc === void 0 ? void 0 : qc.overallStatus) || 'hasErrors' }, errors.length === 0 ? this.renderStats() : this.renderErrors());
  }
  static get style() { return nxtRowCss; }
};

var __rest$3 = (undefined && undefined.__rest) || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
const missingEndColor = '#BBBBBB';
const BASE_MIN_WIDTH_PX$3 = 4;
function SequenceMarkerMissingEndsUnmemoed(_a) {
  var { deletion, pixelsPerBase } = _a, rest = __rest$3(_a, ["deletion", "pixelsPerBase"]);
  const { start: begin, length } = deletion;
  const end = begin + length;
  const x = begin * pixelsPerBase;
  let width = (end - begin) * pixelsPerBase;
  width = Math.max(width, BASE_MIN_WIDTH_PX$3);
  let rectEl;
  let divEl;
  let tip;
  const rangeStr = formatRange$1(begin, end);
  const showTip = async () => {
    if (tip === undefined) {
      tip = await attachTooltip(rectEl, divEl, true);
    }
  };
  const tooltip = (h("div", { ref: init => (divEl = init) },
    h("nxt-tip", null,
      h("div", null,
        h("div", null, `Not sequenced: ${rangeStr}`)))));
  return (h("rect", Object.assign({ ref: init => (rectEl = init), fill: missingEndColor, x: x, y: "-10", width: width, height: "30" }, rest, { onMouseEnter: showTip }), tooltip));
}

function ListOfPcrPrimersChanged({ pcrPrimersChanged }) {
  return (h("div", null,
    `PCR primer changes: (${pcrPrimersChanged.length})`,
    (pcrPrimersChanged.length && (h("ul", null, pcrPrimersChanged.map(({ name }) => {
      return h("li", { key: name }, name);
    })))) ||
      null));
}

var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
const BASE_MIN_WIDTH_PX$2 = 4;
function SequenceMarkerMutation(_a) {
  var { substitution, pixelsPerBase } = _a, rest = __rest$2(_a, ["substitution", "pixelsPerBase"]);
  const { pos, queryNuc, aaSubstitutions = [], aaDeletions = [], pcrPrimersChanged = [] } = substitution;
  const fill = getNucleotideColor(queryNuc);
  const x = pos * pixelsPerBase;
  const width = Math.max(BASE_MIN_WIDTH_PX$2, 1 * pixelsPerBase);
  const totalAaChanges = aaSubstitutions.length + aaDeletions.length;
  let rectEl;
  let divEl;
  let tip;
  const showTip = async () => {
    if (tip === undefined) {
      tip = await attachTooltip(rectEl, divEl, true);
    }
  };
  const tooltip = (h("div", { ref: init => (divEl = init) },
    h("nxt-tip", null,
      h("div", null,
        h("table", { class: "mb-1" },
          h("thead", null),
          h("tbody", null,
            h("tr", null,
              h("td", { colSpan: 2 },
                h("span", null, "Nucleotide substitution"),
                h("span", null, " "),
                h("span", null,
                  h(NucleotideMutationBadge, { mutation: substitution })))),
            totalAaChanges > 0 && (h("tr", null,
              h("td", { colSpan: 2 },
                h("b", { class: "mt-1" }, "Affected codons:")))),
            aaSubstitutions.map(mut => (h("tr", { key: mut.codon },
              h("td", null, "Aminoacid substitution"),
              h("td", null,
                h(AminoacidMutationBadge, { mutation: mut, geneMap: GENE_MAP }))))),
            aaDeletions.map(del => (h("tr", { key: del.queryContext },
              h("td", null, "Aminoacid deletion"),
              h("td", null,
                h(AminoacidMutationBadge, { mutation: del, geneMap: GENE_MAP }))))),
            h("tr", null,
              h("td", { colSpan: 2 }, pcrPrimersChanged.length > 0 && (h("tr", { class: "mt-2" },
                h("td", null,
                  h(ListOfPcrPrimersChanged, { pcrPrimersChanged: pcrPrimersChanged }))))))))))));
  return (h("rect", Object.assign({ ref: init => (rectEl = init), y: "-10", height: "30" }, { fill, x, width }, rest, { onMouseEnter: showTip }), tooltip));
}

var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
const BASE_MIN_WIDTH_PX$1 = 4;
const missingColor = getNucleotideColor('N');
function SequenceMarkerMissing(_a) {
  var { missing, pixelsPerBase } = _a, rest = __rest$1(_a, ["missing", "pixelsPerBase"]);
  const { begin, end } = missing;
  const fill = missingColor;
  const x = begin * pixelsPerBase;
  let width = (end - begin) * pixelsPerBase;
  width = Math.max(width, BASE_MIN_WIDTH_PX$1);
  let rectEl;
  let divEl;
  let tip;
  const showTip = async () => {
    if (tip === undefined) {
      tip = await attachTooltip(rectEl, divEl, true);
    }
  };
  const rangeStr = formatRange(begin, end);
  const tooltip = (h("div", { ref: init => (divEl = init) },
    h("nxt-tip", null,
      h("div", null,
        h("div", null, `Missing: ${rangeStr}`)))));
  return (h("rect", Object.assign({ ref: init => (rectEl = init), y: "-10", height: "30" }, { fill, x, width }, rest, { onMouseEnter: showTip }), tooltip));
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
const BASE_MIN_WIDTH_PX = 4;
const fill = getNucleotideColor('-');
function SequenceMarkerGap(_a) {
  var { deletion, pixelsPerBase } = _a, rest = __rest(_a, ["deletion", "pixelsPerBase"]);
  const { start: begin, length, aaSubstitutions, aaDeletions } = deletion;
  const end = begin + length;
  let width = (end - begin) * pixelsPerBase;
  width = Math.max(width, BASE_MIN_WIDTH_PX);
  const halfNuc = Math.max(pixelsPerBase, BASE_MIN_WIDTH_PX) / 2; // Anchor on the center of the first nuc
  const x = begin * pixelsPerBase - halfNuc;
  const rangeStr = formatRange(begin, end);
  const totalAaChanges = aaSubstitutions.length + aaDeletions.length;
  let rectEl;
  let divEl;
  let tip;
  const showTip = async () => {
    if (tip === undefined) {
      tip = await attachTooltip(rectEl, divEl, true);
    }
  };
  const tooltip = (h("div", { ref: init => (divEl = init) },
    h("nxt-tip", null,
      h("div", null,
        h("table", { class: "mb-1" },
          h("thead", null),
          h("tbody", null,
            h("tr", null,
              h("td", { colSpan: 2 }, `Gap: ${rangeStr}`)),
            totalAaChanges > 0 && (h("tr", null,
              h("td", { colSpan: 2 },
                h("b", { class: "mt-1" }, "Affected codons:")))),
            aaSubstitutions.map(mut => (h("tr", { key: mut.codon },
              h("td", null, "Aminoacid substitution"),
              h("td", null,
                h(AminoacidMutationBadge, { mutation: mut, geneMap: GENE_MAP }))))),
            aaDeletions.map(del => (h("tr", { key: del.queryContext },
              h("td", null, "Aminoacid deletion"),
              h("td", null,
                h(AminoacidMutationBadge, { mutation: del, geneMap: GENE_MAP })))))))))));
  return (h("rect", Object.assign({ ref: init => (rectEl = init), y: "-10", height: "30" }, { fill, x, width }, rest, { onMouseEnter: showTip }), tooltip));
}

const nxtSequenceCss = ":host{display:block}:host>svg{width:inherit;height:inherit}:host>svg>rect:focus{outline:none}";

let NxtSequence$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.missing = [];
    this.substitutions = [];
    this.deletions = [];
    this.alignmentStart = 0;
    this.alignmentEnd = 0;
    this.genomeSize = 0;
    this.pixelsPerBase = 0;
    this.width = 0;
  }
  async componentDidLoad() {
    const { width } = this.hostEl.getBoundingClientRect();
    this.pixelsPerBase = width / this.genomeSize;
    this.width = width;
  }
  renderMissingEnds() {
    return [
      { start: 0, length: this.alignmentStart },
      { start: this.alignmentEnd, length: this.genomeSize - this.alignmentEnd },
    ].map(missingEnd => {
      return h$1(SequenceMarkerMissingEndsUnmemoed, { deletion: missingEnd, pixelsPerBase: this.pixelsPerBase });
    });
  }
  renderMutations() {
    return this.substitutions.map(substitution => h$1(SequenceMarkerMutation, { substitution: substitution, pixelsPerBase: this.pixelsPerBase }));
  }
  renderMissing() {
    return this.missing.map(oneMissing => {
      return h$1(SequenceMarkerMissing, { missing: oneMissing, pixelsPerBase: this.pixelsPerBase });
    });
  }
  renderDeletions() {
    return this.deletions.map(deletion => {
      return h$1(SequenceMarkerGap, { deletion: deletion, pixelsPerBase: this.pixelsPerBase });
    });
  }
  render() {
    return (h$1("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: `0 0 ${this.width} 10`, preserveAspectRatio: "none" }, h$1("rect", { fill: "transparent", x: "0", y: "0", width: this.width, height: "10" }), this.renderMissingEnds(), this.renderMutations(), this.renderMissing(), this.renderDeletions()));
  }
  get hostEl() { return this; }
  static get style() { return nxtSequenceCss; }
};

const nxtSortCss = ":host>div{display:flex;flex-direction:row;flex:1 1 auto;justify-content:center;align-items:center}:host>div>div{display:flex;justify-content:center}:host>div>div.label{display:flex;flex:1 1 auto}:host>div>div.button-wrapper{flex-direction:column;justify-self:flex-end}:host>div>div.button-wrapper>button{background-color:#555;border:none;margin:0.1rem 0;margin-left:0.2rem;color:#eee;outline:none}:host>div>div.button-wrapper>button.active{background-color:#ffffff66}";

let NxtSort$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.dir = '';
    this.sortAsc = () => {
      this.dir = this.sortFn('asc');
    };
    this.sortDesc = () => {
      this.dir = this.sortFn('desc');
    };
  }
  render() {
    return (h$1(Host, null, h$1("div", null, h$1("div", { class: "label" }, h$1("slot", null)), h$1("div", { class: "button-wrapper" }, h$1("button", { class: {
        active: this.dir === 'asc',
      }, type: "button", onClick: this.sortAsc }, h$1("svg", { stroke: "currentColor", fill: "currentColor", "stroke-width": "0", viewBox: "0 0 16 16", height: "8px", width: "8px", xmlns: "http://www.w3.org/2000/svg" }, h$1("path", { d: "M7.247 4.86l-4.796 5.481c-.566.647-.106 1.659.753 1.659h9.592a1 1 0 00.753-1.659l-4.796-5.48a1 1 0 00-1.506 0z" }))), h$1("button", { class: {
        active: this.dir === 'desc',
      }, type: "button", onClick: this.sortDesc }, h$1("svg", { stroke: "currentColor", fill: "currentColor", "stroke-width": "0", viewBox: "0 0 16 16", height: "8px", width: "8px", xmlns: "http://www.w3.org/2000/svg" }, h$1("path", { d: "M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 01.753 1.659l-4.796 5.48a1 1 0 01-1.506 0z" })))))));
  }
  static get style() { return nxtSortCss; }
};

const sortBy = (field) => (dir = '') => (a, b) => {
  var _a, _b;
  const first = (_a = getPath(a, field)) !== null && _a !== void 0 ? _a : Infinity;
  const second = (_b = getPath(b, field)) !== null && _b !== void 0 ? _b : Infinity;
  if (isNullish(dir) || first === second)
    return 0;
  switch (dir) {
    case 'asc':
      return second > first ? 1 : -1;
    case 'desc':
      return second > first ? -1 : 1;
    default:
      return 0;
  }
};

const FILTER_DELIMITERS = /[\n\r,;]/gi;
function splitFilterString(filter) {
  return filter
    .split(FILTER_DELIMITERS)
    .map(f => f.trim())
    .filter(f => f !== '');
}

const filterBySeqName = (seqNamesFilter) => {
  const seqNamesFilters = splitFilterString(seqNamesFilter);
  return (result) => {
    return seqNamesFilters.length === 0 || seqNamesFilters.some(filter => result.seqName.toLowerCase().includes(filter.toLowerCase()));
  };
};

function parsePosition(raw) {
  if (!notUndefinedOrNull(raw) || raw.length === 0 || raw === ANY) {
    return undefined;
  }
  const num = Number.parseInt(raw, 10);
  if (!Number.isFinite(num)) {
    return undefined;
  }
  return num - 1;
}

function parseAminoacid(raw) {
  if (!notUndefinedOrNull(raw) || raw.length === 0 || raw === ANY) {
    return undefined;
  }
  return raw.toUpperCase();
}
function parseGene(raw) {
  if (!notUndefinedOrNull(raw) || raw.length === 0 || raw === ANY) {
    return undefined;
  }
  return raw;
}
function parseAminoacidChange(formatted) {
  const match = /^(?<gene>.*):(?<refAA>[.a-z]{0,1})(?<codon>(\d)*)(?<queryAA>[.a-z]{0,1})$/i.exec(formatted);
  const { groups } = match !== null && match !== void 0 ? match : {};
  if (groups === undefined || Object.values(groups).every(s => s.length === 0)) {
    return undefined;
  }
  const gene = parseGene(groups === null || groups === void 0 ? void 0 : groups.gene);
  const refAA = parseAminoacid(groups === null || groups === void 0 ? void 0 : groups.refAA);
  const codon = parsePosition(groups === null || groups === void 0 ? void 0 : groups.codon);
  const queryAA = parseAminoacid(groups === null || groups === void 0 ? void 0 : groups.queryAA);
  const result = { gene, refAA, codon, queryAA };
  if (Object.values(result).every(r => r === undefined)) {
    return undefined;
  }
  return result;
}

const intersectionWith = (a, b, comp) => a.filter(x => b.findIndex(y => comp(x, y)) !== -1);

function aminoacidChangesAreEqual(filter, actual) {
  const geneMatch = filter.gene === undefined || filter.gene === actual.gene;
  const posMatch = filter.codon === undefined || filter.codon === actual.codon;
  const refNucMatch = filter.refAA === undefined || filter.refAA === actual.refAA;
  const queryNucMatch = filter.queryAA === undefined || filter.queryAA === actual.queryAA;
  return geneMatch && posMatch && refNucMatch && queryNucMatch;
}
const filterByAminoacidChanges = (aaFilter) => {
  const aaFilters = splitFilterString(aaFilter).map(parseAminoacidChange).filter(notUndefined);
  return (result) => {
    const { aaSubstitutions = [], aaDeletions = [] } = result;
    // Make deletions look like substitutions
    const aaDeletionsLikeSubstitutions = aaDeletions.map(del => (Object.assign(Object.assign({}, del), { queryAa: AMINOACID_GAP })));
    // We want to search for both, the substitutions and deletions
    const aaChanges = [...aaSubstitutions, ...aaDeletionsLikeSubstitutions];
    return aaFilters.length === 0 || intersectionWith(aaFilters, aaChanges, aminoacidChangesAreEqual).length > 0;
  };
};

function parseNucleotide(raw) {
  if (raw === undefined || raw === null || raw.length === 0 || raw === ANY) {
    return undefined;
  }
  return raw.toUpperCase();
}
function parseMutation(formatted) {
  const match = /^(?<refNuc>[.a-z-]{0,1})(?<pos>(\d)*)(?<queryNuc>[.a-z-]{0,1})$/i.exec(formatted);
  const { groups } = match !== null && match !== void 0 ? match : {};
  if (groups === undefined || Object.values(groups).every(s => s.length === 0)) {
    return undefined;
  }
  const refNuc = parseNucleotide(groups === null || groups === void 0 ? void 0 : groups.refNuc);
  const pos = parsePosition(groups === null || groups === void 0 ? void 0 : groups.pos);
  const queryNuc = parseNucleotide(groups === null || groups === void 0 ? void 0 : groups.queryNuc);
  const result = { refNuc, pos, queryNuc };
  if (Object.values(result).every(r => r === undefined)) {
    return undefined;
  }
  return result;
}

function mutationsAreEqual(filter, actual) {
  const posMatch = filter.pos === undefined || filter.pos === actual.pos;
  const refNucMatch = filter.refNuc === undefined || filter.refNuc === actual.refNuc;
  const queryNucMatch = filter.queryNuc === undefined || filter.queryNuc === actual.queryNuc;
  return posMatch && refNucMatch && queryNucMatch;
}
const filterByNucleotideMutations = (mutationsFilter) => {
  const mutationFilters = splitFilterString(mutationsFilter).map(parseMutation).filter(notUndefined);
  return (result) => {
    const { substitutions = [], errors = [] } = result;
    if (substitutions.length === 0) {
      return errors.length > 0;
    }
    return mutationFilters.length === 0 || intersectionWith(mutationFilters, substitutions, mutationsAreEqual).length > 0;
  };
};

const filterByClades = (cladesFilter) => {
  const cladesFilters = splitFilterString(cladesFilter);
  return (result) => {
    const { clade, errors = [] } = result;
    if (clade === undefined) {
      return errors.length > 0;
    }
    return cladesFilters.length === 0 || cladesFilters.some(filter => clade.startsWith(filter));
  };
};

const filterByQCIssues = (v) => (d) => {
  var _a;
  const status = ((_a = d === null || d === void 0 ? void 0 : d.qc) === null || _a === void 0 ? void 0 : _a.overallStatus) || 'errors';
  return v.includes(status);
};

const closeIcon = () => (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
  h("title", null, "Close"),
  h("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" })));
const filterIcon = () => (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
  h("title", null, "Funnel"),
  h("path", { d: "M35.4 87.12l168.65 196.44A16.07 16.07 0 01208 294v119.32a7.93 7.93 0 005.39 7.59l80.15 26.67A7.94 7.94 0 00304 440V294a16.07 16.07 0 014-10.44L476.6 87.12A14 14 0 00466 64H46.05A14 14 0 0035.4 87.12z", "stroke-linecap": "round", "stroke-linejoin": "round", class: "fill-none with-stroke" })));

const nxtTableCss = ":host{display:flex;flex:1 1 0;flex-direction:column;font-family:Helvetica, Arial, sans-serif;font-weight:300;--background-color:#555;--border-color:#777;--color:#eee;--color-green-dark:#00857c;--color-blue-mid:#007ca5}:host>table{width:100%;font-size:10pt;border-collapse:collapse}:host>table>thead{width:inherit;background-color:var(--background-color);color:var(--color);font-size:1rem}:host>table>thead>td{padding:0.5rem;border-width:0;border-right-width:1px;border-right-style:solid;border-bottom-width:1px;border-bottom-style:solid;border-color:var(--border-color);vertical-align:middle;text-align:center}:host>table>thead>td:last-child{border-right:none}:host>.table-head,:host .table-filter{display:flex;flex:1 1 auto;padding:0.5rem 0}:host>.table-head{align-items:flex-end;justify-content:space-between;padding-right:0.5rem}:host>.table-head>span>button{padding:0.5rem 1rem;background-color:#fff;border-radius:10rem;border:0.125rem solid var(--color-green-dark);color:var(--color-green-dark);outline:none}:host>.table-head>span>button>span{display:flex;align-items:center}:host>.table-head>span>button>span>svg{width:1rem;height:1rem;margin-right:0.2rem;fill:var(--color-green-dark)}:host>.table-head>span>button>span>svg path.with-stroke{stroke:var(--color-green-dark);stroke-width:40}:host>.table-head>span>button>span>svg path.fill-none{fill:none}:host>.table-head>span>button:active{background-color:var(--color-blue-mid);border-color:var(--color-blue-mid);color:#eee}:host>.table-head>span>button:active span svg{fill:#eee}:host>.table-head>span>button:active span svg path.with-stroke{stroke:#eee}:host>.table-filter{background-color:var(--background-color);color:var(--color);font-size:1rem;justify-content:space-evenly;padding:0;border-width:0;border-bottom-width:1px;border-bottom-style:solid;border-color:var(--border-color)}";

const sortBySeqname = sortBy('seqName');
const sortByQc = sortBy('qc.overallScore');
const sortByClade = sortBy('clade');
const sortByMut = sortBy('totalSubstitutions');
const sortByNonAcgtn = sortBy('totalNonACGTNs');
const sortByMissing = sortBy('totalMissing');
const sortByGaps = sortBy('totalDeletions');
const sortByInsertions = sortBy('totalInsertions');
const sortByFrameShifts = sortBy('totalFrameShifts');
let NxtTable$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.data = null;
    this.hiddenColumns = [];
    this.genomeSize = 0;
    this.indexedData = [];
    this.filtersOpen = false;
    this.seqNameDirection = '';
    this.qcDirection = '';
    this.cladeDirection = '';
    this.mutDirection = '';
    this.NonAcgtnDirection = '';
    this.missingDirection = '';
    this.gapsDirection = '';
    this.insertionsDirection = '';
    this.frameShiftsDirection = '';
    this.seqNameTerm = '';
    this.nucTerm = '';
    this.aaTerm = '';
    this.cladeTerm = '';
    this.qcTerm = ['good', 'mediocre', 'bad', 'errors'];
    this.order = (data) => {
      return data
        .filter(filterBySeqName(this.seqNameTerm))
        .filter(filterByNucleotideMutations(this.nucTerm))
        .filter(filterByAminoacidChanges(this.aaTerm))
        .filter(filterByClades(this.cladeTerm))
        .filter(filterByQCIssues(this.qcTerm))
        .sort(sortBySeqname(this.seqNameDirection))
        .sort(sortByQc(this.qcDirection))
        .sort(sortByClade(this.cladeDirection))
        .sort(sortByMut(this.mutDirection))
        .sort(sortByNonAcgtn(this.NonAcgtnDirection))
        .sort(sortByMissing(this.missingDirection))
        .sort(sortByGaps(this.gapsDirection))
        .sort(sortByInsertions(this.insertionsDirection))
        .sort(sortByFrameShifts(this.frameShiftsDirection));
    };
    this.sortHandler = (state) => (dir) => {
      this[state] = dir !== this[state] ? dir : '';
      this._data = this.order(this.indexedData);
      return this[state];
    };
    this.filterHandler = (state) => (term) => {
      if (term !== this[state]) {
        this[state] = term;
        this._data = this.order(this.indexedData);
      }
    };
    this.toggleFilters = () => {
      this.filtersOpen = !this.filtersOpen;
    };
    this.filterHandlers = {
      seqName: this.filterHandler('seqNameTerm'),
      nucChanges: this.filterHandler('nucTerm'),
      aaChanges: this.filterHandler('aaTerm'),
      cladeChanges: this.filterHandler('cladeTerm'),
      statusChanges: this.filterHandler('qcTerm'),
    };
  }
  preprocessData(dataIn) {
    this.indexedData = dataIn.map((seq, index) => {
      var _a;
      this.genomeSize = Math.max(this.genomeSize, (_a = seq === null || seq === void 0 ? void 0 : seq.alignmentEnd) !== null && _a !== void 0 ? _a : 0);
      return Object.assign(Object.assign({}, seq), { index });
    });
    this._data = this.order(this.indexedData);
  }
  componentWillLoad() {
    this.preprocessData(this.data);
  }
  renderSortFields() {
    const fields = [
      { field: 'seqNameDirection', label: 'Sequence name' },
      { field: 'qcDirection', label: 'QC' },
      { field: 'cladeDirection', label: 'Clade' },
      { field: 'mutDirection', label: 'Mut.' },
      { field: 'NonAcgtnDirection', label: 'non-ACGTN' },
      { field: 'missingDirection', label: 'Ns' },
      { field: 'gapsDirection', label: 'Gaps' },
      { field: 'insertionsDirection', label: 'Ins.' },
      { field: 'frameShiftsDirection', label: 'FS' },
    ];
    return fields
      .filter((_, i) => !this.hiddenColumns.includes(i))
      .map(({ field, label }) => (h$1("td", null, h$1("nxt-sort", { sortFn: this.sortHandler(field) }, label))));
  }
  render() {
    var _a;
    if (this.data === null) {
      return;
    }
    return (h$1(Host, null, h$1("div", { class: "table-head", part: "table-head" }, h$1("nxt-logo", { part: "logo" }), h$1("span", null, h$1("button", { onClick: this.toggleFilters }, h$1("span", null, this.filtersOpen ? closeIcon() : filterIcon(), this.filtersOpen ? 'Close' : 'Filter')))), h$1("div", { class: { 'table-filter': true, 'open': this.filtersOpen }, part: "table-filter" }, h$1("nxt-filter", { open: this.filtersOpen, handlers: this.filterHandlers })), h$1("table", null, h$1("thead", null, this.renderSortFields(), !this.hiddenColumns.includes(9) ? (h$1("td", null, h$1("p", null, "Sequence view"))) : null), h$1("tbody", null, (_a = this._data) === null || _a === void 0 ? void 0 : _a.map(assignment => (h$1("nxt-row", { key: assignment.seqName, data: assignment, genomeSize: this.genomeSize, hiddenColumns: this.hiddenColumns })))))));
  }
  get hostEl() { return this; }
  static get watchers() { return {
    "data": ["preprocessData"]
  }; }
  static get style() { return nxtTableCss; }
};

const nxtTipCss = ":host{background-color:white;box-shadow:0.1rem 0.1rem 0.3rem 0.1rem rgba(0, 0, 0, 0.37);border-radius:0.2rem;display:flex;flex:1 1 auto;flex-direction:column;font-family:Helvetica, Arial, sans-serif;font-weight:300}:host>div{padding:1rem}:host ::slotted(div){padding:1rem}:host ::slotted(*){color:#333;line-height:1.5}";

let NxtTip$1 = class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return (h$1(Host, null, h$1("slot", null)));
  }
  static get style() { return nxtTipCss; }
};

const NxtButton = /*@__PURE__*/proxyCustomElement(NxtButton$1, [1,"nxt-button"]);
const NxtCircle = /*@__PURE__*/proxyCustomElement(NxtCircle$1, [1,"nxt-circle",{"status":[1]}]);
const NxtFilter = /*@__PURE__*/proxyCustomElement(NxtFilter$1, [2,"nxt-filter",{"open":[4],"handlers":[16],"status":[32]}]);
const NxtLogo = /*@__PURE__*/proxyCustomElement(NxtLogo$1, [1,"nxt-logo"]);
const NxtMutations = /*@__PURE__*/proxyCustomElement(NxtMutations$1, [1,"nxt-mutations",{"data":[16],"open":[32]}]);
const NxtQc = /*@__PURE__*/proxyCustomElement(NxtQc$1, [1,"nxt-qc",{"data":[16],"open":[32]}]);
const NxtRow = /*@__PURE__*/proxyCustomElement(NxtRow$1, [1,"nxt-row",{"data":[16],"genomeSize":[2,"genome-size"],"summary":[4],"hiddenColumns":[16]}]);
const NxtSequence = /*@__PURE__*/proxyCustomElement(NxtSequence$1, [1,"nxt-sequence",{"missing":[16],"substitutions":[16],"deletions":[16],"alignmentStart":[2,"alignment-start"],"alignmentEnd":[2,"alignment-end"],"genomeSize":[2,"genome-size"],"pixelsPerBase":[32],"width":[32]}]);
const NxtSort = /*@__PURE__*/proxyCustomElement(NxtSort$1, [1,"nxt-sort",{"sortFn":[16],"dir":[32]}]);
const NxtTable = /*@__PURE__*/proxyCustomElement(NxtTable$1, [1,"nxt-table",{"data":[16],"hiddenColumns":[16],"_data":[32],"filtersOpen":[32],"seqNameDirection":[32],"qcDirection":[32],"cladeDirection":[32],"mutDirection":[32],"NonAcgtnDirection":[32],"missingDirection":[32],"gapsDirection":[32],"insertionsDirection":[32],"frameShiftsDirection":[32],"seqNameTerm":[32],"nucTerm":[32],"aaTerm":[32],"cladeTerm":[32],"qcTerm":[32]}]);
const NxtTip = /*@__PURE__*/proxyCustomElement(NxtTip$1, [1,"nxt-tip"]);
const defineCustomElements = (opts) => {
  if (typeof customElements !== 'undefined') {
    [
      NxtButton,
  NxtCircle,
  NxtFilter,
  NxtLogo,
  NxtMutations,
  NxtQc,
  NxtRow,
  NxtSequence,
  NxtSort,
  NxtTable,
  NxtTip
    ].forEach(cmp => {
      if (!customElements.get(cmp.is)) {
        customElements.define(cmp.is, cmp, opts);
      }
    });
  }
};

defineCustomElements();

</script>
